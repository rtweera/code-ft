// Copyright (c) 2018 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/cache;
import ballerina/crypto;
import ballerina/jballerina.java;
import ballerina/lang.'int;
import ballerina/lang.'string;
import ballerina/log;
import ballerina/time;

# Represents JWT validator configurations.
#
# + issuer - Expected issuer, which is mapped to the `iss`
# + username - Expected username, which is mapped to the `sub`
# + audience - Expected audience, which is mapped to the `aud`
# + jwtId - Expected JWT ID, which is mapped to the `jti`
# + keyId - Expected JWT key ID, which is mapped the `kid`
# + customClaims - Expected map of custom claims
# + clockSkew - Clock skew (in seconds) that can be used to avoid token validation failures due to clock synchronization problems
# + signatureConfig - JWT signature configurations
# + cacheConfig - Configurations related to the cache, which are used to store parsed JWT information
public type ValidatorConfig record {
    string issuer?;
    string username?;
    string|string[] audience?;
    string jwtId?;
    string keyId?;
    map<json> customClaims?;
    decimal clockSkew = 0;
    ValidatorSignatureConfig signatureConfig?;
    cache:CacheConfig cacheConfig?;
};

# Represents JWT signature configurations.
#
# + jwksConfig - JWKS configurations
# + certFile - Public certificate file path or a `crypto:PublicKey`
# + trustStoreConfig - JWT TrustStore configurations
# + secret - HMAC secret configuration
public type ValidatorSignatureConfig record {|
    record {|
        string url;
        cache:CacheConfig cacheConfig?;
        ClientConfiguration clientConfig = {};
    |} jwksConfig?;
    string|crypto:PublicKey certFile?;
    record {|
        crypto:TrustStore trustStore;
        string certAlias;
    |} trustStoreConfig?;
    string secret?;
|};

# Represents the configurations of the client used to call the JWKS endpoint.
#
# + httpVersion - The HTTP version of the client
# + secureSocket - SSL/TLS-related configurations
public type ClientConfiguration record {|
    HttpVersion httpVersion = HTTP_1_1;
    SecureSocket secureSocket?;
|};

# Represents the HTTP versions.
public enum HttpVersion {
    HTTP_1_1,
    HTTP_2
}

# Represents the SSL/TLS configurations.
#
# + disable - Disable SSL validation
# + cert - Configurations associated with the `crypto:TrustStore` or single certificate file that the client trusts
# + key - Configurations associated with the `crypto:KeyStore` or combination of certificate and private key of the client
public type SecureSocket record {|
    boolean disable = false;
    crypto:TrustStore|string cert?;
    crypto:KeyStore|CertKey key?;
|};

# Represents the combination of the certificate file path, private key file path, and private key password if encrypted.
#
# + certFile - A file containing the certificate
# + keyFile - A file containing the private key
# + keyPassword - Password of the private key (if encrypted)
public type CertKey record {|
   string certFile;
   string keyFile;
   string keyPassword?;
|};

# Validates the provided JWT, against the provided configurations.
#```ballerina
# jwt:Payload result = check jwt:validate(jwt, validatorConfig);
# ```
#
# + jwt - JWT that needs to be validated
# + validatorConfig - JWT validator configurations
# + return - `jwt:Payload` or else a `jwt:Error` if an error occurred
public isolated function validate(string jwt, ValidatorConfig validatorConfig) returns Payload|Error {
    return validateJwt(jwt, validatorConfig);
}

isolated function validateJwt(string jwt, ValidatorConfig validatorConfig, cache:Cache? jwksCache = ())
                              returns Payload|Error {
    [Header, Payload] [header, payload] = check decode(jwt);
    if !validateMandatoryHeaderFields(header) {
        return prepareError("Mandatory field signing algorithm (alg) is not provided in JOSE header.");
    }
    check validateJwtRecords(header, payload, validatorConfig);
    check validateSignature(jwt, header, payload, validatorConfig, jwksCache);
    return payload;
}

# Decodes the provided JWT into the header and payload.
# ```ballerina
# [jwt:Header, jwt:Payload] [header, payload] = check jwt:decode(jwt);
# ```
#
# + jwt - JWT that needs to be decoded
# + return - The `jwt:Header` and `jwt:Payload` as a tuple or else a `jwt:Error` if an error occurred
public isolated function decode(string jwt) returns [Header, Payload]|Error {
    string[] encodedJwtComponents = check getJwtComponents(jwt);
    Header header = check getHeader(encodedJwtComponents[0]);
    Payload payload = check getPayload(encodedJwtComponents[1]);
    return [header, payload];
}

isolated function getJwtComponents(string jwt) returns string[]|Error {
    string[] jwtComponents = re `\.`.split(jwt);
    if jwtComponents.length() < 2 || jwtComponents.length() > 3 {
        return prepareError("Invalid JWT.");
    }
    return jwtComponents;
}

isolated function getHeader(string encodedHeader) returns Header|Error {
    byte[]|Error decodedHeader = decodeBase64Url(encodedHeader);
    if decodedHeader is byte[] {
        string|error result = 'string:fromBytes(decodedHeader);
        if result is string {
            json|error jsonHeader = result.fromJsonString();
            if jsonHeader is json {
                return parseHeader(<map<json>> jsonHeader);
            } else {
                return prepareError("String to JSON conversion failed for JWT header.", jsonHeader);
            }
        } else {
            return prepareError("Failed to convert byte[] of decoded header to string.", result);
        }
    } else {
        return prepareError("Base64 URL decode failed for JWT header.", decodedHeader);
    }
}

isolated function getPayload(string encodedPayload) returns Payload|Error {
    byte[]|Error decodedPayload = decodeBase64Url(encodedPayload);
    if decodedPayload is byte[] {
        string|error result = 'string:fromBytes(decodedPayload);
        if result is string {
            json|error jsonPayload = result.fromJsonString();
            if jsonPayload is json {
                return parsePayload(<map<json>> jsonPayload);
            } else {
                return prepareError("String to JSON conversion failed for JWT paylaod.", jsonPayload);
            }
        } else {
            return prepareError("Failed to convert byte[] of decoded payload to string.", result);
        }
    } else {
        return prepareError("Base64 URL decode failed for JWT payload.", decodedPayload);
    }
}

isolated function getJwtSignature(string encodedSignature) returns byte[]|Error {
    byte[]|Error signature = decodeBase64Url(encodedSignature);
    if signature is byte[] {
        return signature;
    } else {
        return prepareError("Base64 URL decode failed for JWT signature.", signature);
    }
}

isolated function parseHeader(map<json> headerMap) returns Header|Error {
    Header header = {};
    string[] keys = headerMap.keys();
    foreach string key in keys {
        match key {
            ALG => {
                if headerMap[key] == "RS256" {
                    header.alg = RS256;
                } else if headerMap[key] == "RS384" {
                    header.alg = RS384;
                } else if headerMap[key] == "RS512" {
                    header.alg = RS512;
                } else if headerMap[key] == "HS256" {
                    header.alg = HS256;
                } else if headerMap[key] == "HS384" {
                    header.alg = HS384;
                } else if headerMap[key] == "HS512" {
                    header.alg = HS512;
                } else {
                    return prepareError("Unsupported signing algorithm '" + headerMap[key].toString() + "'.");
                }
            }
            TYP => {
                header.typ = <string>headerMap[key];
            }
            CTY => {
                header.cty = <string>headerMap[key];
            }
            KID => {
                header.kid = <string>headerMap[key];
            }
            _ => {
                header[key] = headerMap[key];
            }
        }
    }
    return header;
}

isolated function parsePayload(map<json> payloadMap) returns Payload|Error {
    Payload payload = {};
    string[] keys = payloadMap.keys();
    foreach string key in keys {
        match key {
            ISS => {
                payload.iss = <string>payloadMap[key];
            }
            SUB => {
                payload.sub = <string>payloadMap[key];
            }
            AUD => {
                payload.aud = payloadMap[key] is json[] ? check convertToStringArray(<json[]>payloadMap[key]) : <string>payloadMap[key];
            }
            EXP => {
                string exp = payloadMap[key].toString();
                int|error value = 'int:fromString(exp);
                if value is int {
                    payload.exp = value;
                } else {
                    payload.exp = 0;
                }
            }
            NBF => {
                string nbf = payloadMap[key].toString();
                int|error value = 'int:fromString(nbf);
                if value is int {
                    payload.nbf = value;
                } else {
                    payload.nbf = 0;
                }
            }
            IAT => {
                string iat = payloadMap[key].toString();
                int|error value = 'int:fromString(iat);
                if value is int {
                    payload.iat = value;
                } else {
                    payload.iat = 0;
                }
            }
            JTI => {
                payload.jti = <string>payloadMap[key];
            }
            _ => {
                payload[key] = payloadMap[key];
            }
        }
    }
    return payload;
}

isolated function validateSignature(string jwt, Header header, Payload payload, ValidatorConfig validatorConfig,
                                    cache:Cache? jwksCache) returns Error? {
    SigningAlgorithm alg = <SigningAlgorithm>header?.alg;  // The `()` value is already validated.
    ValidatorSignatureConfig? validatorSignatureConfig = validatorConfig?.signatureConfig;

    if alg == NONE && validatorSignatureConfig is () {
        return;
    }

    if alg == NONE && (validatorSignatureConfig is ValidatorSignatureConfig) {
        return prepareError("Not a valid JWS. Signing algorithm is 'NONE'.");
    }

    string[] encodedJwtComponents = check getJwtComponents(jwt);
    if alg != NONE && (validatorSignatureConfig is ValidatorSignatureConfig) {
        if encodedJwtComponents.length() == 2 {
            return prepareError("Not a valid JWS. Signature part is required.");
        }
    }

    string headerPayloadPart = encodedJwtComponents[0] + "." + encodedJwtComponents[1];
    byte[] assertion = headerPayloadPart.toBytes();
    byte[] signature = check getJwtSignature(encodedJwtComponents[2]);

    if validatorSignatureConfig is ValidatorSignatureConfig {
        var jwksConfig = validatorSignatureConfig?.jwksConfig;
        var certFile = validatorSignatureConfig?.certFile;
        var trustStoreConfig = validatorSignatureConfig?.trustStoreConfig;
        string? secret = validatorSignatureConfig?.secret;
        if jwksConfig !is () {
            string? kid = header?.kid;
            if kid is string {
                string url = <string> jwksConfig?.url;
                ClientConfiguration clientConfig = <ClientConfiguration> jwksConfig?.clientConfig;
                json jwk = check getJwk(kid, url, clientConfig, jwksCache);
                if jwk is () {
                    return prepareError("No JWK found for kid '" + kid + "'.");
                }
                crypto:PublicKey publicKey = check getPublicKeyByJwks(jwk);
                boolean signatureValidation = check assertRsaSignature(alg, assertion, signature, publicKey);
                if !signatureValidation {
                   return prepareError("JWT signature validation with JWKS configurations has failed.");
                }
            } else {
                return prepareError("Key ID (kid) is not provided in JOSE header.");
            }
        } else if certFile !is () {
            crypto:PublicKey|crypto:Error publicKey;
            if certFile is crypto:PublicKey {
                publicKey = certFile;
            } else {
                publicKey = crypto:decodeRsaPublicKeyFromCertFile(certFile);
            }
            if publicKey is crypto:PublicKey {
                if !validateCertificate(publicKey) {
                   return prepareError("Public key certificate validity period has passed.");
                }
                boolean signatureValidation = check assertRsaSignature(alg, assertion, signature, publicKey);
                if !signatureValidation {
                   return prepareError("JWT signature validation with public key configurations has failed.");
                }
            } else {
                return prepareError("Failed to decode public key.", publicKey);
            }
        } else if trustStoreConfig !is () {
            crypto:TrustStore trustStore = <crypto:TrustStore> trustStoreConfig?.trustStore;
            string certAlias = <string> trustStoreConfig?.certAlias;
            crypto:PublicKey|crypto:Error publicKey = crypto:decodeRsaPublicKeyFromTrustStore(trustStore, certAlias);
            if publicKey is crypto:PublicKey {
                if !validateCertificate(publicKey) {
                   return prepareError("Public key certificate validity period has passed.");
                }
                boolean signatureValidation = check assertRsaSignature(alg, assertion, signature, publicKey);
                if !signatureValidation {
                   return prepareError("JWT signature validation with TrustStore configurations has failed.");
                }
            } else {
                return prepareError("Failed to decode public key.", publicKey);
            }
        } else if secret !is () {
            boolean signatureValidation = check assertHmacSignature(alg, assertion, signature, secret);
            if !signatureValidation {
               return prepareError("JWT signature validation with shared secret has failed.");
            }
        }
    }
}

isolated function validateJwtRecords(Header header, Payload payload, ValidatorConfig validatorConfig) returns Error? {
    string? sub = validatorConfig?.username;
    if sub is string {
        check validateUsername(payload, sub);
    }
    string? iss = validatorConfig?.issuer;
    if iss is string {
        check validateIssuer(payload, iss);
    }
    string|string[]? aud = validatorConfig?.audience;
    if aud is string || aud is string[] {
        check validateAudience(payload, aud);
    }
    string? jwtId = validatorConfig?.jwtId;
    if jwtId is string {
        check validateJwtId(payload, jwtId);
    }
    string? keyId = validatorConfig?.keyId;
    if keyId is string {
        check validateKeyId(header, keyId);
    }
    map<json>? customClaims = validatorConfig?.customClaims;
    if customClaims is map<json> {
        check validateCustomClaims(payload, customClaims);
    }
    int? exp = payload?.exp;
    if exp is int {
        if !validateExpirationTime(exp, <int> validatorConfig.clockSkew) {
            return prepareError("JWT is expired.");
        }
    }
    int? nbf = payload?.nbf;
    if nbf is int {
        if !validateNotBeforeTime(nbf, <int> validatorConfig.clockSkew) {
            return prepareError("JWT is used before not-before-time (nbf).");
        }
    }
    return;
}

isolated function validateMandatoryHeaderFields(Header header) returns boolean {
    SigningAlgorithm? alg = header?.alg;
    return alg is SigningAlgorithm;
}

isolated function validateCertificate(crypto:PublicKey publicKey) returns boolean {
    [int, decimal] currentTime = time:utcNow();
    crypto:Certificate? certificate = publicKey?.certificate;
    if certificate is crypto:Certificate {
        [int, decimal] notBefore = certificate.notBefore;
        [int, decimal] notAfter = certificate.notAfter;
        if currentTime[0] >= notBefore[0] && currentTime[0] <= notAfter[0] {
            return true;
        }
    }
    return false;
}

isolated function getPublicKeyByJwks(json jwk) returns crypto:PublicKey|Error {
    json|error modulus = jwk.n;
    json|error exponent = jwk.e;
    if modulus is string && exponent is string {
        crypto:PublicKey|crypto:Error publicKey = crypto:buildRsaPublicKey(modulus, exponent);
        if publicKey is crypto:PublicKey {
            return publicKey;
        } else {
            return prepareError("Public key generation failed.", publicKey);
        }
    } else if modulus is error {
        return prepareError("Failed to access modulus from the JWK '" + jwk.toString() + "'.");
    } else if exponent is error {
        return prepareError("Failed to access exponent from the JWK '" + jwk.toString() + "'.");
    } else {
        return prepareError("Failed to access modulus or exponent as a 'string' property from the JWK '" + jwk.toString() + "'.");
    }
}

isolated function getJwk(string kid, string url, ClientConfiguration clientConfig, cache:Cache? jwksCache) returns json|Error {
    if jwksCache is cache:Cache {
        if jwksCache.hasKey(kid) {
            any|cache:Error jwk = jwksCache.get(kid);
            if jwk is json {
                return jwk;
            } else {
                log:printDebug("Failed to retrieve JWK for the kid '" + kid + "' from the cache.");
            }
        }
    }
    string|Error stringResponse = getJwksResponse(url, clientConfig);
    if stringResponse is string {
        json[] jwksArray = check getJwksArray(stringResponse);
        foreach json jwk in jwksArray {
            json|error responseKid = jwk.kid;
            if responseKid is json && responseKid == kid {
                return jwk;
            }
        }
    } else {
        return prepareError("Failed to call JWKS endpoint '" + url + "'.", stringResponse);
    }
}

isolated function getJwksArray(string stringResponse) returns json[]|Error {
    json|error jsonResponse = stringResponse.fromJsonString();
    if jsonResponse is json {
        json|error jwks = jsonResponse.keys;
        if jwks is json {
            return <json[]> jwks;
        } else {
            return prepareError("Failed to access 'keys' property from the JSON '" + jsonResponse.toString() + "'.", jwks);
        }
    } else {
        return prepareError("Failed to convert '" + stringResponse + "' to JSON.", jsonResponse);
    }
}

isolated function getJwksResponse(string url, ClientConfiguration clientConfig) returns string|Error = @java:Method {
    'class: "io.ballerina.stdlib.jwt.JwksClient"
} external;

isolated function assertRsaSignature(SigningAlgorithm alg, byte[] assertion, byte[] signaturePart,
                                     crypto:PublicKey publicKey) returns boolean|Error {
    match alg {
        RS256 => {
            boolean|crypto:Error result = crypto:verifyRsaSha256Signature(assertion, signaturePart, publicKey);
            if result is boolean {
                return result;
            } else {
                return prepareError("SHA256 signature verification failed.", result);
            }
        }
        RS384 => {
            boolean|crypto:Error result = crypto:verifyRsaSha384Signature(assertion, signaturePart, publicKey);
            if result is boolean {
                return result;
            } else {
                return prepareError("SHA384 signature verification failed.", result);
            }
        }
        RS512 => {
            boolean|crypto:Error result = crypto:verifyRsaSha512Signature(assertion, signaturePart, publicKey);
            if result is boolean {
                return result;
            } else {
                return prepareError("SHA512 signature verification failed.", result);
            }
        }
    }
    return prepareError("Unsupported RSA algorithm '" + alg.toString() + "'.");
}

isolated function assertHmacSignature(SigningAlgorithm alg, byte[] assertion, byte[] signaturePart,
                                      string secret) returns boolean|Error {
    match alg {
        HS256 => {
            byte[]|crypto:Error signature = crypto:hmacSha256(assertion, secret.toBytes());
            if signature is byte[] {
                return signature == signaturePart;
            } else {
                return prepareError("HMAC secret key validation failed for SHA256 algorithm.", signature);
            }
        }
        HS384 => {
            byte[]|crypto:Error signature = crypto:hmacSha384(assertion, secret.toBytes());
            if signature is byte[] {
                return signature == signaturePart;
            } else {
                return prepareError("HMAC secret key validation failed for SHA384 algorithm.", signature);
            }
        }
        HS512 => {
            byte[]|crypto:Error signature = crypto:hmacSha512(assertion, secret.toBytes());
            if signature is byte[] {
                return signature == signaturePart;
            } else {
                return prepareError("HMAC secret key validation failed for SHA512 algorithm.", signature);
            }
        }
    }
    return prepareError("Unsupported HMAC algorithm '" + alg.toString() + "'.");
}

isolated function validateUsername(Payload payload, string usernameConfig) returns Error? {
    string? usernamePayload = payload?.sub;
    if usernamePayload is string {
        if usernamePayload != usernameConfig {
            return prepareError("JWT contained invalid username '" + usernamePayload + "'");
        }
        return;
    } else {
        return prepareError("JWT must contain a valid username.");
    }
}

isolated function validateIssuer(Payload payload, string issuerConfig) returns Error? {
    string? issuePayload = payload?.iss;
    if issuePayload is string {
        if issuePayload != issuerConfig {
            return prepareError("JWT contained invalid issuer name '" + issuePayload + "'");
        }
        return;
    } else {
        return prepareError("JWT must contain a valid issuer name.");
    }
}

isolated function validateAudience(Payload payload, string|string[] audienceConfig) returns Error? {
    string|string[]? audiencePayload = payload?.aud;
    if audiencePayload is string {
        if audienceConfig is string {
            if audiencePayload == audienceConfig {
                return;
            }
        } else {
            foreach string audience in audienceConfig {
                if audience == audiencePayload {
                    return;
                }
            }
        }
        return prepareError("JWT contained invalid audience.");
    } else if audiencePayload is string[] {
        if audienceConfig is string {
            foreach string audience in audiencePayload {
                if audience == audienceConfig {
                    return;
                }
            }
        } else {
            foreach string audienceC in audienceConfig {
                foreach string audienceP in audiencePayload {
                    if audienceC == audienceP {
                        return;
                    }
                }
            }
        }
        return prepareError("JWT contained invalid audience.");
    } else {
        return prepareError("JWT must contain a valid audience.");
    }
}

isolated function validateJwtId(Payload payload, string jwtIdConfig) returns Error? {
    string? jwtIdPayload = payload?.jti;
    if jwtIdPayload is string {
        if jwtIdPayload != jwtIdConfig {
            return prepareError("JWT contained invalid JWT ID '" + jwtIdPayload + "'");
        }
        return;
    } else {
        return prepareError("JWT must contain a valid JWT ID.");
    }
}

isolated function validateKeyId(Header header, string keyIdConfig) returns Error? {
    string? keyIdHeader = header?.kid;
    if keyIdHeader is string {
        if keyIdHeader != keyIdConfig {
            return prepareError("JWT contained invalid key ID '" + keyIdHeader + "'");
        }
        return;
    } else {
        return prepareError("JWT must contain a valid key ID.");
    }
}

isolated function validateCustomClaims(Payload payload, map<json> customClaims) returns Error? {
    foreach string key in customClaims.keys() {
        json customClaimPayload = payload[key].toJson();
        if customClaimPayload is () {
            return prepareError("JWT must contain a '" + key + "' custom claim.");
        }
        json customClaimConfig = customClaims[key];
        if customClaimPayload.toString() != customClaimConfig.toString() {
            return prepareError("JWT contained invalid custom claim '" + key + ": " + customClaimPayload.toString() + "'");
        }
    }
}

isolated function validateExpirationTime(int expTime, int clockSkew) returns boolean {
    [int, decimal] currentTime = time:utcNow();
    if clockSkew > 0 {
        return expTime + clockSkew >= currentTime[0];
    } else {
        return expTime >= currentTime[0];
    }
}

isolated function validateNotBeforeTime(int nbf, int clockSkew) returns boolean {
    [int, decimal] currentTime = time:utcNow();
    if clockSkew > 0 {
        return nbf - clockSkew <= currentTime[0];
    } else {
        return nbf <= currentTime[0];
    }
}

isolated function convertToStringArray(json[] jsonData) returns string[]|Error {
    string[] values = [];
    int i = 0;
    foreach json jsonVal in jsonData {
        values[i] = jsonVal.toString();
        i = i + 1;
    }
    return values;
}

// Copyright (c) 2025 WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/jballerina.java;

isolated function init() {
    setModule();
}

isolated function setModule() = @java:Method {
    'class: "io.ballerina.lib.ai.ModuleUtils"
} external;

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.org) All Rights Reserved.
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/io;
import ballerina/lang.regexp;
import ballerina/log;
import ballerina/yaml;

# Provides extracted tools and service URL from the OpenAPI specification.
public type HttpApiSpecification record {|
    # Extracted service URL from the OpenAPI specification if there is any
    string serviceUrl?;
    # Extracted Http tools from the OpenAPI specification
    HttpTool[] tools;
|};

# Defines additional information to be extracted from the OpenAPI specification.
public type AdditionInfoFlags record {|
    # Flag to extract description of parameters and schema attributes from the OpenAPI specification
    boolean extractDescription = false;
    # Flag to extract default values of parameters and schema attributes from the OpenAPI specification
    boolean extractDefault = false;
|};

# Extracts the Http tools from the given OpenAPI specification file.
#
# + filePath - Path to the OpenAPI specification file (should be JSON or YAML)
# + additionInfoFlags - Flags to extract additional information from the OpenAPI specification
# + return - A record with the list of extracted tools and the service URL (if available)
public isolated function extractToolsFromOpenApiSpecFile(string filePath, *AdditionInfoFlags additionInfoFlags)
returns HttpApiSpecification & readonly|Error {
    if !filePath.endsWith(".yaml") && !filePath.endsWith(".yml") && !filePath.endsWith(".json") {
        return error Error("Unsupported file type. Supported file types are .json, .yaml or .yml");
    }
    map<json> openApiSpec = check readOpenApiSpec(filePath);
    return extractToolsFromOpenApiJsonSpec(openApiSpec, additionInfoFlags);
}

isolated function readOpenApiSpec(string filePath) returns map<json>|Error {
    map<json>|error openApiSpec;
    if filePath.endsWith(".yaml") || filePath.endsWith(".yml") {
        openApiSpec = yaml:readFile(filePath).ensureType();
    } else {
        openApiSpec = io:fileReadJson(filePath).ensureType();
    }
    if openApiSpec is error {
        return error Error(openApiSpec.message(), openApiSpec);
    }
    return openApiSpec;
}

# Extracts the Http tools from the given OpenAPI specification as a JSON 
#
# + openApiSpec - A valid OpenAPI specification in JSON format
# + additionInfoFlags - Flags to extract additional information from the OpenAPI specification
# + return - A record with the list of extracted tools and the service URL (if available)
public isolated function extractToolsFromOpenApiJsonSpec(map<json> openApiSpec, *AdditionInfoFlags additionInfoFlags) returns
HttpApiSpecification & readonly|Error {
    OpenApiSpec spec = check parseOpenApiSpec(openApiSpec);
    OpenApiSpecVisitor visitor = new (additionInfoFlags);
    HttpApiSpecification & readonly|error httpApiSpecification = visitor.visit(spec).cloneReadOnly();
    if httpApiSpecification is error {
        return error Error(httpApiSpecification.message(), httpApiSpecification.cause(), detail = httpApiSpecification.detail());
    }
    return httpApiSpecification;
}

# Parses the given OpenAPI specification as a JSON to a OpenApiSpec object.
#
# + openApiSpec - A valid OpenAPI specification in JSON format
# + return - A OpenApiSpec object
public isolated function parseOpenApiSpec(map<json> openApiSpec) returns OpenApiSpec|UnsupportedOpenApiVersion|OpenApiParsingError {
    if !openApiSpec.hasKey("openapi") {
        return error UnsupportedOpenApiVersion("Unsupported API definition. Supports specifications with version 3.x.x only.");
    }
    json version = openApiSpec.get("openapi");
    if version !is string || !version.matches(re `3\.(0|1)\..`) {
        return error UnsupportedOpenApiVersion("Unsupported OpenAPI version. Supports specifications with version 3.x.x only.");
    }
    OpenApiSpec|error parseSpec = openApiSpec.cloneWithType();
    if parseSpec is OpenApiSpec {
        return parseSpec;
    }
    return error OpenApiParsingError("Error while parsing the OpenAPI specification.", cause = parseSpec);
}

class OpenApiSpecVisitor {
    private map<ComponentType> referenceMap = {};
    private final HttpTool[] tools = [];
    private final AdditionInfoFlags additionalInfoFlags;

    isolated function init(AdditionInfoFlags additionalInfoFlags = {}) {
        self.additionalInfoFlags = additionalInfoFlags.cloneReadOnly();
    }

    isolated function visit(OpenApiSpec openApiSpec) returns HttpApiSpecification|error {
        string? serviceUrl = self.visitServers(openApiSpec.servers);
        self.referenceMap = self.visitComponents(openApiSpec.components);

        Paths? paths = openApiSpec.paths;
        error? parsingError = ();
        if paths !is () {
            parsingError = trap check self.visitPaths(paths);
        }
        if parsingError is () {
            return {
                serviceUrl,
                tools: self.tools.cloneReadOnly()
            };
        }
        if parsingError.message().includes("{ballerina}StackOverflow") {
            return error ParsingStackOverflowError("Parsing failed due to either a cyclic reference or the excessive length of the specification.", cause = parsingError);
        }
        return error OpenApiParsingError("Error while parsing the OpenAPI specification.", cause = parsingError);
    }

    private isolated function visitServers(Server[]? servers) returns string? {
        if servers is () || servers.length() < 1 {
            return ();
        }
        if servers.length() > 1 {
            log:printWarn("Multiple server urls are defined in the OpenAPI specification. If not specified, toolkit will use " + servers[0].url);
        }
        return servers[0].url;
    }

    private isolated function visitComponents(Components? components) returns map<ComponentType> {
        if components is () {
            return {};
        }
        map<ComponentType> referenceMap = {};
        foreach [string, anydata] [componentType, componentMap] in components.entries() {
            if componentMap !is map<ComponentType|Reference> {
                continue;
            }
            foreach [string, ComponentType|Reference] [componentName, component] in componentMap.entries() {
                string ref = string `#/${OPENAPI_COMPONENTS_KEY}/${componentType}/${componentName}`;
                referenceMap[ref] = component;
            }
        }
        return referenceMap;
    }

    private isolated function visitPaths(Paths paths) returns error? {
        foreach [string, PathItem|Reference] [pathUrl, pathItem] in paths.entries() {
            if pathItem is Reference {
                check self.visitPathItem(pathUrl, check self.visitReference(pathItem).ensureType());
            } else if pathItem is PathItem {
                check self.visitPathItem(pathUrl, pathItem);
            } else {
                return error("Unsupported path item type.", 'type = typeof pathItem);
            }
        }
    }

    private isolated function visitPathItem(string pathUrl, PathItem pathItem) returns error? {
        HttpMethod[] supportedMethods = [GET, POST, PUT, DELETE, OPTIONS, HEAD, PATCH];
        foreach HttpMethod httpMethod in supportedMethods {
            string method = httpMethod.toLowerAscii();
            if !pathItem.hasKey(method) {
                continue;
            }
            anydata operation = pathItem.get(method);
            if operation is Operation {
                check self.visitOperation(pathUrl, httpMethod, operation);
            }
        }
    }

    private isolated function visitOperation(string path, HttpMethod method, Operation operation) returns error? {
        string? description = operation.description ?: operation.summary;
        if description is () {
            return error IncompleteSpecificationError(string `A summary or description is mandatory for API paths. But it is missing for the resource "[${method}]:${path}"`);
        }
        string? name = operation.operationId;
        if name is () {
            return error(string `OperationId is mandotory for API paths. But, it is missing for the resource "[${method}]:${path}"`);
        }

        // resolve parameters
        map<ParameterSchema>? parameters = check self.visitParameters(operation.parameters);

        RequestBodySchema? requestBody = ();
        RequestBody|Reference? requestBodySchema = operation.requestBody;
        if requestBodySchema is Reference {
            RequestBody resolvedRequestBody = check self.visitReference(requestBodySchema).ensureType();
            requestBody = check self.visitRequestBody(resolvedRequestBody);
        } else if requestBodySchema is RequestBody {
            requestBody = check self.visitRequestBody(requestBodySchema);
        }

        self.tools.push({
            name,
            description,
            path,
            method,
            parameters,
            requestBody
        });
    }

    private isolated function visitContent(map<MediaType> content) returns record {|string mediaType; Schema schema;|}|error {
        // check for json content
        foreach [string, MediaType] [key, value] in content.entries() {
            if key.trim().matches(re `(application/.*json|${XML_MEDIA}|text/.*plain|\*/\*)`) {
                return {
                    mediaType: key,
                    schema: value.schema
                };
            }
        }
        return error UnsupportedMediaTypeError("Only json, xml or text content is supported.", availableContentTypes = content.keys());
    }

    private isolated function visitRequestBody(RequestBody requestBody) returns RequestBodySchema|OpenApiParsingError|error {
        map<MediaType> content = requestBody.content;
        string mediaType;
        Schema schema;
        {mediaType, schema} = check self.visitContent(content);
        if !mediaType.matches(re `${XML_MEDIA}`) {
            return {
                mediaType,
                schema: check self.visitSchema(schema)
            };
        }
        string? xmlName = schema.'xml?.name;
        string outerBlockName;
        if xmlName is string {
            outerBlockName = xmlName;
        } else if schema is Reference {
            outerBlockName = regexp:split(re `/`, schema.\$ref).pop();
        } else {
            return error OpenApiParsingError("Error while parsing the OpenAPI specification. The schema should have a name for xml content type.", cause = schema);
        }
        schema = {'type: OBJECT, properties: {[outerBlockName] : schema}};
        return {
            mediaType,
            schema: check self.visitSchema(schema, true)
        };

    }

    private isolated function visitParameters((Parameter|Reference)[]? parameters) returns map<ParameterSchema>?|error {
        if parameters is () || parameters.length() == 0 {
            return ();
        }
        map<ParameterSchema> parameterSchemas = {};

        foreach Parameter|Reference param in parameters {
            Parameter resolvedParameter;
            if param is Reference {
                resolvedParameter = check self.visitReference(param).ensureType();
            } else if param is Parameter {
                resolvedParameter = param;
            } else {
                continue;
            }

            ParameterLocation location = resolvedParameter.'in;
            if location !is PATH|QUERY {
                continue;
            }

            string name = resolvedParameter.name;
            EncodingStyle? style = resolvedParameter.style;
            boolean? explode = resolvedParameter.explode;
            if location is PATH && (style is LABEL|MATRIX || explode == true) {
                return error UnsupportedSerializationError("Only simple style parameters are supported for path parameters at this time.", 'parameter = name);
            }

            Schema? schema;
            string? mediaType = ();
            map<MediaType>? content = resolvedParameter.content;
            if content is () {
                schema = resolvedParameter.schema;
            }
            else {
                {mediaType, schema} = check self.visitContent(content);
            }
            if schema is () {
                return error InvalidParameterDefinition("Resource paramters should have either a schema or a content.", 'parameter = name);
            }

            parameterSchemas[name] = {
                location,
                mediaType,
                schema: check self.visitSchema(schema),
                style,
                explode,
                required: resolvedParameter.required,
                description: resolvedParameter.description,
                allowEmptyValue: resolvedParameter.allowEmptyValue,
                nullable: resolvedParameter.nullable
            };
        }
        return parameterSchemas;
    }

    private isolated function visitReference(Reference reference) returns ComponentType|InvalidReferenceError {
        if !self.referenceMap.hasKey(reference.\$ref) {
            return error InvalidReferenceError("Missing component object for the given reference", reference = reference.\$ref);
        }
        ComponentType|Reference component = self.referenceMap.get(reference.\$ref);
        if component is Reference {
            return self.visitReference(component);
        }
        if component !is Schema {
            return component;
        }
        string? xmlName = component.'xml?.name;
        string? xmlPrefix = component.'xml?.prefix;
        if xmlName !is () {
            reference.'xml.name = xmlName;
        }
        if xmlPrefix !is () {
            reference.'xml.prefix = xmlPrefix;
        }
        return component;
    }

    private isolated function visitSchema(Schema schema, boolean isXml = false) returns JsonSubSchema|error {
        if schema is ObjectSchema {
            return self.visitObjectSchema(schema, isXml);
        }
        if schema is ArraySchema {
            return self.visitArraySchema(schema, isXml);
        }
        if schema is PrimitiveTypeSchema {
            return self.visitPrimitiveTypeSchema(schema, isXml);
        }
        if schema is AnyOfSchema {
            return self.visitAnyOfSchema(schema, isXml);
        }
        if schema is OneOfSchema {
            return self.visitOneOfSchema(schema, isXml);
        }
        if schema is AllOfSchema {
            return self.visitAllOfSchema(schema, isXml);
        }
        if schema is NotSchema {
            return self.visitNotSchema(schema, isXml);
        }
        Schema resolvedSchema = check self.visitReference(<Reference>schema).ensureType();
        return check self.visitSchema(resolvedSchema, isXml);
    }

    private isolated function wrapObjectSchema(string? xmlName, string? xmlNamespace, string? xmlPrefix, string? refName, ObjectInputSchema|ArrayInputSchema|PrimitiveInputSchema inputSchema) returns ObjectInputSchema|error {
        ObjectInputSchema outerObjectSchema = {
            'type: OBJECT,
            properties: {}
        };
        if xmlName is string {
            outerObjectSchema.properties[self.getPropertyName(xmlName, xmlPrefix)] = inputSchema;
        } else if refName is string {
            outerObjectSchema.properties[self.getPropertyName(refName, xmlPrefix)] = inputSchema;
        }
        if xmlNamespace is string {
            string namespaceProperty = xmlPrefix is string ? string `${XML_NAMESPACE}:${xmlPrefix}` : XML_NAMESPACE;
            outerObjectSchema.properties[namespaceProperty] = {'const: xmlNamespace};
        }
        if inputSchema is PrimitiveInputSchema {
            outerObjectSchema.properties[XML_CONTENT] = inputSchema;
        }
        return outerObjectSchema;
    }

    private isolated function visitObjectSchema(ObjectSchema schema, boolean isXml) returns ObjectInputSchema|error {
        ObjectInputSchema objectSchema = {
            'type: OBJECT,
            properties: {}
        };
        if isXml {
            string? xmlNamespace = schema.'xml?.namespace;
            string? xmlPrefix = schema.'xml?.prefix;
            if xmlNamespace is string {
                string namespaceProperty = xmlPrefix is string ? string `${XML_NAMESPACE}:${xmlPrefix}` : XML_NAMESPACE;
                objectSchema.properties[namespaceProperty] = {'const: xmlNamespace};
            }
        }

        if schema?.properties == () {
            return objectSchema;
        }

        map<Schema> properties = <map<Schema>>schema?.properties;
        if properties.length() == 0 {
            return objectSchema;
        }

        foreach [string, Schema] [propertyName, property] in properties.entries() {
            if property.'xml?.name is () {
                property.'xml.name = propertyName;
            }
            JsonSubSchema resolvedPropertySchema = check self.visitSchema(property, isXml);
            if !isXml {
                objectSchema.properties[propertyName] = resolvedPropertySchema;
                continue;
            }
            string? innerXmlName = property.'xml?.name;
            boolean? xmlAttribute = property.'xml?.attribute;
            string? innerXmlPrefix = property.'xml?.prefix;
            string xmlName = propertyName;
            if innerXmlName is string {
                xmlName = innerXmlName;
            }
            string attributePrefix = xmlAttribute is boolean && xmlAttribute ? "@" : "";
            string resolvedPropertyName = self.getPropertyName(xmlName, innerXmlPrefix);
            objectSchema.properties[string `${attributePrefix}${resolvedPropertyName}`] = resolvedPropertySchema;
        }
        boolean|string[]? required = schema?.required;
        if required is string[] {
            objectSchema.required = required;
        }
        return objectSchema;
    }

    private isolated function visitArraySchema(ArraySchema schema, boolean isXml) returns ArrayInputSchema|ObjectInputSchema|error {
        ArrayInputSchema arraySchema = {
            'type: ARRAY,
            items: check self.visitSchema(schema.items, isXml)
        };

        if isXml {
            boolean? xmlWrapped = schema?.'xml?.wrapped;
            string? xmlNamespace = schema?.'xml?.namespace;
            string? xmlPrefix = schema?.'xml?.prefix;
            if xmlWrapped is boolean && xmlWrapped {
                return self.wrapObjectSchema(schema.items.'xml?.name, xmlNamespace, xmlPrefix, schema.'xml?.name, arraySchema);
            }
        }
        return arraySchema;
    }

    private isolated function visitPrimitiveTypeSchema(PrimitiveTypeSchema schema, boolean isXml) returns PrimitiveInputSchema|ObjectInputSchema|error {
        INTEGER|NUMBER|FLOAT|STRING|BOOLEAN 'type = schema.'type;
        PrimitiveInputSchema inputSchema = {
            'type: 'type is FLOAT ? NUMBER : 'type
        };

        if self.additionalInfoFlags.extractDescription {
            inputSchema.description = schema.description;
        }
        if self.additionalInfoFlags.extractDefault {
            inputSchema.default = check schema?.default.ensureType();
        }

        if schema is StringSchema {
            string? pattern = schema.pattern;
            string? format = schema.format;
            if pattern is () && format is string {
                if format == "date" {
                    pattern = OPENAPI_PATTERN_DATE;
                }
                else if format == "date-time" {
                    pattern = OPENAPI_PATTERN_DATE_TIME;
                }
            }

            inputSchema.format = format;
            inputSchema.pattern = pattern;
            inputSchema.'enum = schema.'enum;
        }

        if isXml {
            string? xmlNamespace = schema.'xml?.namespace;
            string? xmlPrefix = schema.'xml?.prefix;
            if xmlNamespace is string {
                return self.wrapObjectSchema((), xmlNamespace, xmlPrefix, (), inputSchema);
            }
        }
        return inputSchema;
    }

    private isolated function visitAnyOfSchema(AnyOfSchema schema, boolean isXml) returns AnyOfInputSchema|error {
        JsonSubSchema[] anyOf = from Schema element in schema.anyOf
            select check self.visitSchema(element, isXml).ensureType();
        return {
            anyOf
        };
    }

    private isolated function visitAllOfSchema(AllOfSchema schema, boolean isXml) returns AllOfInputSchema|error {
        JsonSubSchema[] allOf = from Schema element in schema.allOf
            select check self.visitSchema(element, isXml).ensureType();
        return {
            allOf
        };
    }

    private isolated function visitOneOfSchema(OneOfSchema schema, boolean isXml) returns OneOfInputSchema|error {
        JsonSubSchema[] oneOf = from Schema element in schema.oneOf
            select check self.visitSchema(element, isXml);
        return {
            oneOf
        };
    }

    private isolated function visitNotSchema(NotSchema schema, boolean isXml) returns NotInputSchema|error {
        return {
            not: check self.visitSchema(schema.not, isXml)
        };
    }

    isolated function getPropertyName(string name, string? prefix) returns string =>
        prefix is () ? name : string `${prefix}:${name}`;
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerinax/ai.agent;

type User record {|
    Friend[] friends;
|};

type Friend User;

@agent:Tool
isolated function toolCyclicInput(User user) {
}

// Copyright (c) 2018 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// NOTE: All the tokens/credentials used in this test are dummy tokens/credentials and used only for testing purposes.

import ballerina/crypto;
import ballerina/io;
import ballerina/test;

@test:Config {}
isolated function testValidateJwtWithAudAsArray() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload result = check validate(JWT1, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
    result = check validate(JWT3, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
    result = check validate(JWT4, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtWithSingleAud() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: "ballerina",
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload result = check validate(JWT1, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtWithSingleAudAsArray() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina"],
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload result = check validate(JWT1, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtWithNoIssOrSub() returns Error? {
    ValidatorConfig validatorConfig = {
        audience: "ballerinaSamples",
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload result = check validate(JWT1, validatorConfig);
    test:assertEquals(result?.aud, ["ballerina","ballerinaSamples"]);
}

@test:Config {}
isolated function testValidateJwtWithAllFields() returns Error? {
    ValidatorConfig validatorConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "hello" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload result = check validate(JWT5, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtWithInvalidSub() returns Error? {
    ValidatorConfig validatorConfig = {
        username: "invalid",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "hello" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload|Error result = validate(JWT5, validatorConfig);
    if result is Error {
        assertContains(result, "JWT contained invalid username 'John'");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtWithInvalidIss() {
    ValidatorConfig validatorConfig = {
        username: "John",
        issuer: "invalid",
        audience: ["ballerina", "ballerinaSamples"],
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "hello" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload|Error result = validate(JWT5, validatorConfig);
    if result is Error {
        assertContains(result, "JWT contained invalid issuer name 'wso2'");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtWithInvalidAud() {
    ValidatorConfig validatorConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["invalid1", "invalid2"],
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "hello" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload|Error result = validate(JWT5, validatorConfig);
    if result is Error {
        assertContains(result, "JWT contained invalid audience.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtWithInvalidSingleAud() {
    ValidatorConfig validatorConfig = {
        username: "John",
        issuer: "wso2",
        audience: "invalid",
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "hello" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload|Error result = validate(JWT5, validatorConfig);
    if result is Error {
        assertContains(result, "JWT contained invalid audience.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtWithInvalidSingleAudAsArray() {
    ValidatorConfig validatorConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["invalid"],
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "hello" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload|Error result = validate(JWT5, validatorConfig);
    if result is Error {
        assertContains(result, "JWT contained invalid audience.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtWithInvalidJwtId() {
    ValidatorConfig validatorConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        jwtId: "invalid",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "hello" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload|Error result = validate(JWT5, validatorConfig);
    if result is Error {
        assertContains(result, "JWT contained invalid JWT ID 'JlbmMiOiJBMTI4Q0JDLUhTMjU2In'");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtWithInvalidKeyId() {
    ValidatorConfig validatorConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "invalid",
        customClaims: { "scp": "hello" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload|Error result = validate(JWT5, validatorConfig);
    if result is Error {
        assertContains(result, "JWT contained invalid key ID '5a0b754-895f-4279-8843-b745e11a57e9'");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtWithInvalidCustomClaims() {
    ValidatorConfig validatorConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "invalid" },
        clockSkew: 60,
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    Payload|Error result = validate(JWT5, validatorConfig);
    if result is Error {
        assertContains(result, "JWT contained invalid custom claim 'scp: hello'");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtWithInvalidSignature() {
    ValidatorConfig validatorConfig = {
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "wso2carbon"
            }
        }
    };
    Payload|Error result = validate(JWT1, validatorConfig);
    if result is Error {
        assertContains(result, "SHA256 signature verification failed.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithoutSecureSocket() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks"
            }
        }
    };
    Payload|Error result = validate(JWT2, validatorConfig);
    if result is Error {
        assertContains(result, "Failed to send the request to the endpoint. PKIX path building failed:");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithSslDisabled() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                clientConfig: {
                    httpVersion: HTTP_2,
                    secureSocket: {
                        disable: true
                    }
                }
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithEmptySecureSocket() {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                clientConfig: {
                    httpVersion: HTTP_2,
                    secureSocket: {
                    }
                }
            }
        }
    };
    Payload|Error result = validate(JWT2, validatorConfig);
    if result is Error {
        assertContains(result, "Need to configure 'crypto:TrustStore' or 'cert' with client SSL certificates file.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithValidTrustStore() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                clientConfig: {
                    httpVersion: HTTP_2,
                    secureSocket: {
                        cert: {
                            path: TRUSTSTORE_PATH,
                            password: "ballerina"
                        }
                    }
                }
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithValidCert() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                clientConfig: {
                    httpVersion: HTTP_2,
                    secureSocket: {
                        cert: PUBLIC_CERT_PATH
                    }
                }
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithInvalidCert() {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                clientConfig: {
                    httpVersion: HTTP_2,
                    secureSocket: {
                        cert: INVALID_PUBLIC_CERT_PATH
                    }
                }
            }
        }
    };
    Payload|Error result = validate(JWT2, validatorConfig);
    if result is Error {
        assertContains(result, "Failed to send the request to the endpoint. PKIX path building failed:");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithValidTrustStoreAndValidKeyStore() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                clientConfig: {
                    httpVersion: HTTP_2,
                    secureSocket: {
                        cert: {
                            path: TRUSTSTORE_PATH,
                            password: "ballerina"
                        },
                        key: {
                            path: KEYSTORE_PATH,
                            password: "ballerina"
                        }
                    }
                }
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithValidCertsAndKey() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                clientConfig: {
                    httpVersion: HTTP_2,
                    secureSocket: {
                        cert: PUBLIC_CERT_PATH,
                        key: {
                            certFile: PUBLIC_CERT_PATH,
                            keyFile: PRIVATE_KEY_PATH
                        }
                    }
                }
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testValidateJwtSignatureWithJwkWithValidCertsAndEncryptedKey() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                clientConfig: {
                    httpVersion: HTTP_2,
                    secureSocket: {
                        cert: PUBLIC_CERT_PATH,
                        key: {
                            certFile: PUBLIC_CERT_PATH,
                            keyFile: ENCRYPTED_PRIVATE_KEY_PATH,
                            keyPassword: "ballerina"
                        }
                    }
                }
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testJwksRequestWithoutUrlScheme() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "localhost:9444/oauth2/jwks"
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testJwksRequestWithHttpUrlScheme() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "http://localhost:9444/oauth2/jwks"
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testJwksRequestWithSecureSocketAndWithoutUrlScheme() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "localhost:9445/oauth2/jwks",
                clientConfig: {
                    secureSocket: {
                        cert: PUBLIC_CERT_PATH
                    }
                }
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {
    groups: ["jwks"]
}
isolated function testJwksRequestWithSecureSocketAndWithHttpUrlScheme() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        signatureConfig: {
            jwksConfig: {
                url: "http://localhost:9444/oauth2/jwks",
                clientConfig: {
                    secureSocket: {
                        cert: PUBLIC_CERT_PATH
                    }
                }
            }
        }
    };
    Payload result = check validate(JWT2, validatorConfig);
    test:assertEquals(result?.iss, "ballerina");
}

@test:Config {}
isolated function testValidateJwtSignatureWithPublicCert() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            certFile: PUBLIC_CERT_PATH
        }
    };
    Payload result = check validate(JWT1, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtSignatureWithCryptoPublicKey() returns io:Error|crypto:Error|Error? {
    byte[] pubicCertContent = check io:fileReadBytes(PUBLIC_CERT_PATH);
    crypto:PublicKey publicKey = check crypto:decodeRsaPublicKeyFromContent(pubicCertContent);
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            certFile: publicKey
        }
    };
    Payload result = check validate(JWT1, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtSignatureWithInvalidPublicCert() {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            certFile: INVALID_PUBLIC_CERT_PATH
        }
    };
    Payload|Error result = validate(JWT1, validatorConfig);
    if result is Error {
        assertContains(result, "Public key certificate validity period has passed.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtSignatureWithHS256SharedSecret() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            secret: "s3cr3t"
        }
    };
    Payload result = check validate(JWT6, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtSignatureWithHS384SharedSecret() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            secret: "s3cr3t"
        }
    };
    Payload result = check validate(JWT7, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtSignatureWithHS512SharedSecret() returns Error? {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            secret: "s3cr3t"
        }
    };
    Payload result = check validate(JWT8, validatorConfig);
    test:assertEquals(result?.iss, "wso2");
}

@test:Config {}
isolated function testValidateJwtSignatureWithInvalidSharedSecret() {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            secret: "!nva1id"
        }
    };
    Payload|Error result = validate(JWT6, validatorConfig);
    if result is Error {
        assertContains(result, "JWT signature validation with shared secret has failed.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testValidateJwtSignatureWithInvalidAlgorithm() {
    ValidatorConfig validatorConfig = {
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        clockSkew: 60,
        signatureConfig: {
            certFile: PUBLIC_CERT_PATH
        }
    };
    Payload|Error result = validate(JWT6, validatorConfig);
    if result is Error {
        assertContains(result, "Unsupported RSA algorithm 'HS256'.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

// Copyright (c) 2019 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

# Represents the client JWT Auth provider, which is used to authenticate with an external endpoint by issuing a
# self-signed JWT against the provided JWT issuer configurations.
# ```ballerina
# jwt:ClientSelfSignedJwtAuthProvider provider = new({
#     issuer: "wso2",
#     audience: "ballerina",
#     keyStoreConfig: {
#         keyAlias: "ballerina",
#         keyPassword: "ballerina",
#         keyStore: {
#             path: "/path/to/keystore.p12",
#             password: "ballerina"
#         }
#     }
# });
# ```
public isolated class ClientSelfSignedJwtAuthProvider {

    private final IssuerConfig & readonly issuerConfig;

    # Provides authentication based on the provided JWT configurations.
    #
    # + issuerConfig - JWT issuer configurations
    public isolated function init(IssuerConfig issuerConfig) {
        self.issuerConfig = issuerConfig.cloneReadOnly();
    }

    # Issues a self-signed JWT for authentication.
    # ```ballerina
    # string token = check provider.generateToken();
    # ```
    #
    # + return - Generated token or else a `jwt:Error` if an error occurred
    public isolated function generateToken() returns string|Error {
        string|Error result = issue(self.issuerConfig);
        if result is string {
            return result;
        } else {
            return prepareError("Failed to generate a self-signed JWT.", result);
        }
    }
}

// Copyright (c) 2018 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// NOTE: All the tokens/credentials used in this test are dummy tokens/credentials and used only for testing purposes.

import ballerina/cache;
import ballerina/test;

@test:Config {}
isolated function testListenerJwtAuthProviderSuccess() returns Error? {
    ValidatorConfig jwtConfig = {
        issuer: "wso2",
        audience: "ballerina",
        cacheConfig: {
            capacity: 10,
            evictionFactor: 0.25,
            evictionPolicy: cache:LRU,
            defaultMaxAge: -1,
            cleanupInterval: 3600
        },
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    ListenerJwtAuthProvider jwtAuthProvider = new(jwtConfig);
    Payload result = check jwtAuthProvider.authenticate(JWT1);
    test:assertEquals(result?.iss, "wso2");
    test:assertEquals(result?.aud, ["ballerina","ballerinaSamples"]);
    // Authenticate the token from the cache
    result = check jwtAuthProvider.authenticate(JWT1);
    test:assertEquals(result?.iss, "wso2");
    test:assertEquals(result?.aud, ["ballerina","ballerinaSamples"]);
}

@test:Config {
    groups: ["jwks"]
}
isolated function testListenerJwtAuthProviderSuccessWithJwk() returns Error? {
    ValidatorConfig jwtConfig = {
        issuer: "ballerina",
        audience: "vEwzbcasJVQm1jVYHUHCjhxZ4tYa",
        cacheConfig: {
            capacity: 10,
            evictionFactor: 0.25,
            evictionPolicy: cache:LRU,
            defaultMaxAge: -1,
            cleanupInterval: 3600
        },
        signatureConfig: {
            jwksConfig: {
                url: "https://localhost:9445/oauth2/jwks",
                cacheConfig: {
                    capacity: 10,
                    evictionFactor: 0.25,
                    evictionPolicy: cache:LRU,
                    defaultMaxAge: -1,
                    cleanupInterval: 3600
                },
                clientConfig: {
                    secureSocket: {
                        cert: {
                            path: TRUSTSTORE_PATH,
                            password: "ballerina"
                        }
                    }
                }
            }
        }
    };
    ListenerJwtAuthProvider jwtAuthProvider = new(jwtConfig);
    Payload result = check jwtAuthProvider.authenticate(JWT2);
    test:assertEquals(result?.iss, "ballerina");
    test:assertEquals(result?.aud, ["vEwzbcasJVQm1jVYHUHCjhxZ4tYa"]);
}

@test:Config {}
isolated function testListenerJwtAuthProviderFailure() {
    ValidatorConfig jwtConfig = {
        issuer: "invalid",
        audience: "ballerina",
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    ListenerJwtAuthProvider jwtAuthProvider = new(jwtConfig);
    Payload|Error result = jwtAuthProvider.authenticate(JWT1);
    if result is Error {
        test:assertEquals(result.message(), "JWT validation failed.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testListenerJwtAuthProviderFailureWithInvalidCredential() {
    ValidatorConfig jwtConfig = {
        issuer: "wso2",
        audience: "ballerina",
        signatureConfig: {
            trustStoreConfig: {
                trustStore: {
                    path: TRUSTSTORE_PATH,
                    password: "ballerina"
                },
                certAlias: "ballerina"
            }
        }
    };
    ListenerJwtAuthProvider jwtAuthProvider = new(jwtConfig);
    Payload|Error result = jwtAuthProvider.authenticate("invalid_credential");
    if result is Error {
        test:assertEquals(result.message(), "Credential format does not match to JWT format.");
    } else {
        test:assertFail("Expected error not found.");
    }
}
