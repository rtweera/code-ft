// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

# A client class for interacting with a chat service.
public isolated client class ChatClient {
    private final http:Client httpClient;

    # Initializes the `ChatClient` with the provided service URL and configuration.
    #
    # + serviceUrl - The base URL of the chat service.
    # + clientConfig - Configuration options for the chat client.
    # + return - An `error` if the client initialization fails otherwise nil.
    public function init(string serviceUrl, *ChatClientConfiguration clientConfig) returns error? {
        http:ClientConfiguration clientConfigData = {...clientConfig};
        self.httpClient = check new(serviceUrl, clientConfigData);
    }

    # Handles incoming chat messages by sending a request to the chat service.
    #
    # + request - The chat request message to be sent.
    # + return - A `ChatRespMessage` containing the response from the chat service, or an `error` if the request fails.
    isolated resource function post chat(ChatReqMessage request) returns ChatRespMessage|error {
        return self.httpClient->/chat.post(request);
    }
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/test;
import ballerinax/ai.agent;

@test:Config {}
function testAgentChat() returns error? {
    agent:ChatClient chatClient = check new("http://localhost:9090/chatService");
    agent:ChatReqMessage req = {
        sessionId: "1",
        message: "Hello Ballerina!"
    };
    agent:ChatRespMessage resp = check chatClient->/chat.post(req);
    test:assertEquals(resp.message, "1: Hello Ballerina!", "Invalid response message");
}

import ballerina/io;
import ballerina/test;

@test:Config {}
function testExtractToolsFromWifiOpenAPISpec() returns error? {
    string wifiSpecPath = "tests/resources/openapi/wifi-spec.json";
    map<json> openApiSpec = check io:fileReadJson(wifiSpecPath).ensureType();
    HttpApiSpecification apiSpec = check extractToolsFromOpenApiJsonSpec(openApiSpec);

    HttpTool[] tools = [
        {
            name: "postGuestWifiAccounts",
            description: "Create new guest WiFi account",
            method: "POST",
            path: "/guest-wifi-accounts",
            requestBody: {
                mediaType: "application/json",
                schema:
                    {
                    allOf: [
                        {'type: "object", required: ["email", "username"], properties: {email: {'type: "string"}, username: {'type: "string"}}},
                        {'type: "object", required: ["password"], properties: {password: {'type: "string"}}}
                    ]
                }
            }
        },
        {
            name: "deleteGuestWifiAccountsOwneremailUsername",
            description: "Delete a guest WiFi account",
            method: "DELETE",
            path: "/guest-wifi-accounts/{ownerEmail}/{username}",
            parameters: {
                ownerEmail: {
                    location: PATH,
                    required: true,
                    description: "Email address of the owner of the guest WiFi accounts",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                },
                username: {
                    location: PATH,
                    required: true,
                    description: "Username of the guest WiFi account to be deleted",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                }

            }
        },
        {
            name: "getGuestWifiAccountsOwneremail",
            description: "Get list of guest WiFi accounts of a given owner email address",
            method: GET,
            path: "/guest-wifi-accounts/{ownerEmail}",
            parameters: {
                ownerEmail: {
                    location: PATH,
                    required: true,
                    description: "Email address of the owner of the guest WiFi accounts",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                }

            }
        }
    ];
    test:assertEquals(apiSpec.tools, tools);
    test:assertEquals(apiSpec.serviceUrl, "http://test-wifi-url.com");

}

@test:Config {}
function testExtractToolsFromWifiOpenAPISpecYAMLFile() returns error? {
    string wifiSpecPath = "tests/resources/openapi/wifi-spec.yaml";
    HttpApiSpecification apiSpec = check extractToolsFromOpenApiSpecFile(wifiSpecPath);

    HttpTool[] tools = [
        {
            name: "postGuestWifiAccounts",
            description: "Create new guest WiFi account",
            method: "POST",
            path: "/guest-wifi-accounts",
            requestBody: {
                mediaType: "application/json",
                schema:
                    {
                    allOf: [
                        {'type: "object", required: ["email", "username"], properties: {email: {'type: "string"}, username: {'type: "string"}}},
                        {'type: "object", required: ["password"], properties: {password: {'type: "string"}}}
                    ]
                }
            }
        },
        {
            name: "deleteGuestWifiAccountsOwneremailUsername",
            description: "Delete a guest WiFi account",
            method: "DELETE",
            path: "/guest-wifi-accounts/{ownerEmail}/{username}",
            parameters: {
                ownerEmail: {
                    location: PATH,
                    required: true,
                    description: "Email address of the owner of the guest WiFi accounts",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                },
                username: {
                    location: PATH,
                    required: true,
                    description: "Username of the guest WiFi account to be deleted",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                }
            }
        },
        {
            name: "getGuestWifiAccountsOwneremail",
            description: "Get list of guest WiFi accounts of a given owner email address",
            method: GET,
            path: "/guest-wifi-accounts/{ownerEmail}",
            parameters: {
                ownerEmail: {
                    location: PATH,
                    required: true,
                    description: "Email address of the owner of the guest WiFi accounts",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                }
            }
        }
    ];
    test:assertEquals(apiSpec.tools, tools);
    test:assertEquals(apiSpec.serviceUrl, "http://test-wifi-url.com");
}

@test:Config {}
function testExtractToolsFromWifiOpenAPISpecJSONFile() returns error? {
    string wifiSpecPath = "tests/resources/openapi/wifi-spec.json";
    HttpApiSpecification apiSpec = check extractToolsFromOpenApiSpecFile(wifiSpecPath);

    HttpTool[] tools = [
        {
            name: "postGuestWifiAccounts",
            description: "Create new guest WiFi account",
            method: "POST",
            path: "/guest-wifi-accounts",
            requestBody: {
                mediaType: "application/json",
                schema:
                    {
                    allOf: [
                        {'type: "object", required: ["email", "username"], properties: {email: {'type: "string"}, username: {'type: "string"}}},
                        {'type: "object", required: ["password"], properties: {password: {'type: "string"}}}
                    ]
                }
            }
        },
        {
            name: "deleteGuestWifiAccountsOwneremailUsername",
            description: "Delete a guest WiFi account",
            method: "DELETE",
            path: "/guest-wifi-accounts/{ownerEmail}/{username}",
            parameters: {
                ownerEmail: {
                    location: PATH,
                    required: true,
                    description: "Email address of the owner of the guest WiFi accounts",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                },
                username: {
                    location: PATH,
                    required: true,
                    description: "Username of the guest WiFi account to be deleted",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                }
            }
        },
        {
            name: "getGuestWifiAccountsOwneremail",
            description: "Get list of guest WiFi accounts of a given owner email address",
            method: GET,
            path: "/guest-wifi-accounts/{ownerEmail}",
            parameters: {
                ownerEmail: {
                    location: PATH,
                    required: true,
                    description: "Email address of the owner of the guest WiFi accounts",
                    style: "simple",
                    explode: false,
                    schema: {'type: "string"}
                }
            }
        }
    ];
    test:assertEquals(apiSpec.tools, tools);
    test:assertEquals(apiSpec.serviceUrl, "http://test-wifi-url.com");
}

@test:Config {}
function testExtractToolsFromOpenAPISpecJSONFile2() returns error? {
    string wifiSpecPath = "tests/resources/openapi/openai-spec.json";
    HttpApiSpecification|Error apiSpec = extractToolsFromOpenApiSpecFile(wifiSpecPath);

    if apiSpec is Error {
        test:assertFail("Visitor fails with the error");
    }
    HttpTool[] tools = apiSpec.tools;

    test:assertEquals(tools.length(), 19);
    test:assertEquals(apiSpec.serviceUrl, "https://api.openai.com/v1");

    foreach HttpTool tool in tools {
        if tool.name == "createCompletion" {
            test:assertEquals(tool,
            {
                name: "createCompletion",
                description: "Creates a completion for the provided prompt and parameters",
                method: POST,
                path: "/completions",
                requestBody: {
                    mediaType: "application/json",
                    schema: {
                        'type: "object",
                        properties:
                        {
                            model: {'type: "string"},
                            prompt: {
                                oneOf: [
                                    {'type: "string"},
                                    {'type: "array", items: {'type: "string"}},
                                    {'type: "array", items: {'type: "integer"}},
                                    {
                                        'type: "array",
                                        items: {
                                            'type: "array",
                                            items: {'type: "integer"}
                                        }
                                    }
                                ]
                            },
                            suffix: {'type: "string"},
                            max_tokens: {'type: "integer"},
                            temperature: {'type: "number"},
                            top_p: {'type: "number"},
                            n: {'type: "integer"},
                            'stream: {'type: "boolean"},
                            logprobs: {'type: "integer"},
                            echo: {'type: "boolean"},
                            stop: {oneOf: [{'type: "string"}, {'type: "array", items: {'type: "string"}}]},
                            presence_penalty: {'type: "number"},
                            frequency_penalty: {'type: "number"},
                            best_of: {'type: "integer"},
                            logit_bias: {'type: "object", properties: {}},
                            user: {'type: "string"}
                        },
                        required: [
                            "model"
                        ]
                    }
                }
            });
        } else if tool.name == "createChatCompletion" {
            test:assertEquals(tool, {
                name: "createChatCompletion",
                description: "Creates a completion for the chat message",
                method: POST,
                path: "/chat/completions",
                requestBody: {
                    mediaType: "application/json",
                    schema: {
                        'type: "object",
                        properties: {
                            model: {'type: "string"},
                            messages: {
                                'type: "array",
                                items: {
                                    'type: "object",
                                    required: ["role", "content"],
                                    properties: {role: {'type: "string", 'enum: ["system", "user", "assistant"]}, content: {'type: "string"}, name: {'type: "string"}}
                                }
                            },
                            temperature: {'type: "number"},
                            top_p: {'type: "number"},
                            n: {'type: "integer"},
                            'stream: {'type: "boolean"},
                            stop: {"oneOf": [{'type: "string"}, {'type: "array", items: {'type: "string"}}]},
                            max_tokens: {'type: "integer"},
                            presence_penalty: {'type: "number"},
                            frequency_penalty: {'type: "number"},
                            logit_bias: {'type: "object", properties: {}},
                            user: {'type: "string"}
                        },
                        required: ["model", "messages"]
                    }
                }
            });
        }
    }
}

@test:Config {}
function testExtractToolsFromOpenAPISpecJSONFile3() returns error? {
    string wifiSpecPath = "tests/resources/openapi/openai-spec-with-xml-schema.json";
    HttpApiSpecification|Error apiSpec = extractToolsFromOpenApiSpecFile(wifiSpecPath);

    if apiSpec is Error {
        test:assertFail("Visitor fails with the error");
    }
    HttpTool[] tools = apiSpec.tools;

    test:assertEquals(tools.length(), 19);
    test:assertEquals(apiSpec.serviceUrl, "https://api.openai.com/v1");

    foreach HttpTool tool in tools {
        if tool.name == "createCompletion" {
            test:assertEquals(tool,
            {
                "name": "createCompletion",
                "description": "Creates a completion for the provided prompt and parameters",
                "method": "POST",
                "path": "/completions",
                "requestBody": {
                    "mediaType": "application/xml",
                    "schema": {
                        "type": "object",
                        "properties": {
                            "CreateCompletionRequest": {
                                "type": "object",
                                "required": [
                                    "model"
                                ],
                                "properties": {
                                    "model": {
                                        "type": "string"
                                    },
                                    "prompt": {
                                        "oneOf": [
                                            {
                                                "type": "string"
                                            },
                                            {
                                                "type": "array",
                                                "items": {
                                                    "type": "string"
                                                }
                                            },
                                            {
                                                "type": "array",
                                                "items": {
                                                    "type": "integer"
                                                }
                                            },
                                            {
                                                "type": "array",
                                                "items": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "integer"
                                                    }
                                                }
                                            }
                                        ]
                                    },
                                    "suffix": {
                                        "type": "string"
                                    },
                                    "@maxTokens": {
                                        "type": "integer"
                                    },
                                    "temperature": {
                                        "type": "number"
                                    },
                                    "top_p": {
                                        "type": "number"
                                    },
                                    "n": {
                                        "type": "integer"
                                    },
                                    "stream": {
                                        "type": "boolean"
                                    },
                                    "lgp:logprobs": {
                                        "type": "object",
                                        "properties": {
                                            "@xmlns:lgp": {
                                                "const": "http://openai.com/docs/1.0/parameters"
                                            },
                                            "#content": {
                                                "type": "integer"
                                            }
                                        }
                                    },
                                    "echo": {
                                        "type": "boolean"
                                    },
                                    "stop": {
                                        "oneOf": [
                                            {
                                                "type": "string"
                                            },
                                            {
                                                "type": "array",
                                                "items": {
                                                    "type": "string"
                                                }
                                            }
                                        ]
                                    },
                                    "presence_penalty": {
                                        "type": "number"
                                    },
                                    "frequency_penalty": {
                                        "type": "number"
                                    },
                                    "best_of": {
                                        "type": "integer"
                                    },
                                    "logit_bias": {
                                        "type": "object",
                                        "properties": {}
                                    },
                                    "user": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            });
        } else if tool.name == "createChatCompletion" {
            test:assertEquals(tool, {
                "name": "createChatCompletion",
                "description": "Creates a completion for the chat message",
                "method": "POST",
                "path": "/chat/completions",
                "requestBody": {
                    "mediaType": "application/xml",
                    "schema": {
                        "type": "object",
                        "properties": {
                            "CreateChatCompletionRequest": {
                                "type": "object",
                                "required": [
                                    "model",
                                    "messages"
                                ],
                                "properties": {
                                    "model": {
                                        "type": "string"
                                    },
                                    "messages": {
                                        "type": "object",
                                        "properties": {
                                            "message": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "required": [
                                                        "role",
                                                        "content"
                                                    ],
                                                    "properties": {
                                                        "role": {
                                                            "type": "string",
                                                            "enum": [
                                                                "system",
                                                                "user",
                                                                "assistant"
                                                            ]
                                                        },
                                                        "content": {
                                                            "type": "string"
                                                        },
                                                        "name": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "@temperature": {
                                        "type": "number"
                                    },
                                    "top:top_p": {
                                        "type": "object",
                                        "properties": {
                                            "@xmlns:top": {
                                                "const": "http://openai.com/docs/1.0/parameters"
                                            },
                                            "#content": {
                                                "type": "number"
                                            }
                                        }
                                    },
                                    "n": {
                                        "type": "integer"
                                    },
                                    "stream": {
                                        "type": "boolean"
                                    },
                                    "stop": {
                                        "oneOf": [
                                            {
                                                "type": "string"
                                            },
                                            {
                                                "type": "array",
                                                "items": {
                                                    "type": "string"
                                                }
                                            }
                                        ]
                                    },
                                    "max_tokens": {
                                        "type": "integer"
                                    },
                                    "presence_penalty": {
                                        "type": "number"
                                    },
                                    "frequency_penalty": {
                                        "type": "number"
                                    },
                                    "logit_bias": {
                                        "type": "object",
                                        "properties": {}
                                    },
                                    "user": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }
    }
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

public enum ParameterLocation {
    QUERY = "query", HEADER = "header", PATH = "path", COOKIE = "cookie"
}

public enum EncodingStyle {
    FORM = "form",
    SIMPLE = "simple",
    MATRIX = "matrix",
    LABEL = "label",
    SPACEDELIMITED = "spaceDelimited",
    PIPEDELIMITED = "pipeDelimited",
    DEEPOBJECT = "deepObject"
}

public enum HeaderStyle {
    SIMPLE = "simple"
}

type ComponentType Schema|Response|Parameter|RequestBody|Header|PathItem;

# Map of component objects.
public type Components record {
    # A map of reusable schemas for different data types
    map<Schema|Reference> schemas?;
    # A map of reusable response objects 
    map<Response|Reference> responses?;
    # A map of reusable parameter objects
    map<Parameter|Reference> parameters?;
    # A map of reusable request body objects
    map<RequestBody|Reference> requestBodies?;
    # A map of reusable header objects
    map<Header|Reference> headers?;
    # A map of PathItem objects
    map<PathItem|Reference> pathItems?;
};

# Server information object.
public type Server record {
    # A URL to the target host
    string url;
    # An optional string describing the host designated by the URL
    string description?;
};

# Map of pathItem objects.
public type Paths record {|
    PathItem|Reference...;
|};

# Describes a single path item.
public type PathItem record {
    # Description of the path item
    string description?;
    # Summary of the path item
    string summary?;
    # GET operation
    Operation get?;
    # POST operation
    Operation post?;
    # PUT operation
    Operation put?;
    # DELETE operation
    Operation delete?;
    # OPTIONS operation
    Operation options?;
    # HEAD operation
    Operation head?;
    # PATCH operation
    Operation patch?;
    # TRACE operation
    Operation trace?;
    # Server information for the path
    Server[] servers?;
    # A list of parameters that are applicable for all the operations described under this path item
    (Parameter|Reference)[] parameters?;
    # Not allowed $ref
    never \$ref?;
};

# Describes HTTP headers.
public type Header record {
    # Whether this header parameter is mandatory
    boolean required?;
    # A brief description of the header parameter
    string description?;
    # Whether empty value is allowed
    string allowEmptyValue?;
    # Describes how a specific property value will be serialized depending on its type
    HeaderStyle style?;
    # When this is true, property values of type array or object generate separate parameters for each value of the array, or key-value-pair of the map
    boolean explode?;
    # Schema of the header parameter
    Schema schema?;
    # Content of the header parameter
    map<MediaType> content?;
    # Not allowed $ref
    never \$ref?;
};

# Describes a encoding definition applied to a schema property.
public type Encoding record {
    # Describes how a specific property value will be serialized depending on its type
    string style?;
    # When this is true, property values of type array or object generate separate parameters for each value of the array, or key-value-pair of the map
    boolean explode?;
    # The Content-Type for encoding a specific property
    string contentType?;
    # A map allowing additional information to be provided as headers
    map<Header|Reference> headers?;
};

# Defines media type of a parameter, response body or header.
public type MediaType record {
    # Schema of the content
    Schema schema = {};
    # Encoding of the content
    map<Encoding> encoding?;
};

# Base schema object.
public type BaseSchema record {
    # Description of the schema
    string description?;
    # Default value of the schema
    json default?;
    # Whether the value is nullable
    boolean nullable?;
    # Xml schema
    XmlSchema 'xml?;
    # Not allowed $ref property
    never \$ref?;
};

# Base type schema object.
public type BaseTypeSchema record {
    *BaseSchema;
    # Type of the schema
    string 'type;
    # Not allowed anyOf
    never anyOf?;
    # Not allowed oneOf
    never oneOf?;
    # Not allowed allOf
    never allOf?;
    # Not allowed not
    never not?;

};

# Base primitive type schema object.
public type BasePrimitiveTypeSchema record {
    *BaseTypeSchema;
    # Can not have properties in a primitive type schema
    never properties?;
    # Can not have items in a primitive type schema
    never items?;
};

# Integer schema object.
public type IntegerSchema record {
    *BasePrimitiveTypeSchema;
    # Type of the integer schema
    INTEGER 'type;
    # Format of the value
    string format?;
    # Minimum value of the integer value
    int minimum?;
    # Maximum value of the integer value
    int maximum?;
    # Whether the minimum value is exclusive
    boolean exclusiveMinimum?;
    # Whether the maximum value is exclusive
    boolean exclusiveMaximum?;
    # Multiplier of the integer value
    int multipleOf?;
};

# Number schema object.
public type NumberSchema record {
    *BasePrimitiveTypeSchema;
    # Type of the number schema
    NUMBER|FLOAT 'type;
    # Format of the value
    string format?;
    # Minimum value of the number value
    int|float minimum?;
    # Maximum value of the number value
    int|float maximum?;
    # Whether the minimum value is exclusive
    boolean exclusiveMinimum?;
    # Whether the maximum value is exclusive
    boolean exclusiveMaximum?;
    # Multiplier of the number value
    int|float multipleOf?;
};

# String schema object.
public type StringSchema record {|
    *BasePrimitiveTypeSchema;
    # Type of the string schema
    STRING 'type = STRING;
    # Format of the string
    string format?;
    # Minimum length of the string value
    int minLength?;
    # Maximum length of the string value
    int maxLength?;
    # Regular expression pattern of the string value
    string pattern?;
    # Enum values of the string value
    (PrimitiveType?)[] 'enum?;
|};

# Boolean schema object.
public type BooleanSchema record {
    *BasePrimitiveTypeSchema;
    # Type of the boolean schema
    BOOLEAN 'type;
};

# Primitive type schema object.
public type PrimitiveTypeSchema IntegerSchema|NumberSchema|StringSchema|BooleanSchema;

# Array schema object.
public type ArraySchema record {
    *BaseTypeSchema;
    # Type of the array schema
    ARRAY 'type = ARRAY;
    # Whether the array items are unique
    boolean uniqueItems?;
    # Schema of the array items 
    Schema items;
    # Minimum number of items in the array
    int minItems?;
    # Maximum number of items in the array
    int maxItems?;
    # Not allowed properties
    never properties?;
};

# Discriminator object.
public type Discriminator record {
    # Name of the property that specifies the type
    string propertyName;
    # Mapping of the property values to schema names
    map<string> mapping?;
};

# One of schema object.
public type OneOfSchema record {
    *BaseSchema;
    # List of schemas that should match
    Schema[] oneOf;
    # Discriminator
    Discriminator discriminator?;
};

# All of schema object.
public type AllOfSchema record {
    *BaseSchema;
    # List of schemas that should match
    Schema[] allOf;
};

# Any of schema object.
public type AnyOfSchema record {
    *BaseSchema;
    # List of schemas that should match
    Schema[] anyOf;
    # Discriminator
    Discriminator discriminator?;
};

# Not schema object.
public type NotSchema record {
    *BaseSchema;
    # Schema that should not match
    Schema not;
};

# Defines an bbject schema with type is specified and properties are optional.
public type ObjectSchemaType1 record {
    *BaseTypeSchema;
    # Type of the object schema
    OBJECT 'type;
    # Minimum number of properties in the object
    int minProperties?;
    # Maximum number of properties in the object
    int maxProperties?;
    # List of required properties
    boolean|string[] required?;
    # List of properties
    map<Schema> properties?; // properties are optional for open-ended objects
    # Additional properties
    boolean|Schema additionalProperties?;
    # Discriminator
    Discriminator discriminator?;
    # Not allowed items. Distinction between array and object
    never items?;
};

# Defines an object schema with the properties defined and type is unspecified.
public type ObjectSchemaType2 record {
    *ObjectSchemaType1;
    # To match when type is not specified, but properties are specified
    never 'type?;
    # List of properties
    map<Schema> properties;
};

# Defines an object schema.
public type ObjectSchema ObjectSchemaType1|ObjectSchemaType2;

public type XmlSchema record {|
    # Replaces the name of the element/attribute used for the described schema property.
    string name?;
    # The URI of the namespace definition.
    string namespace?;
    # The prefix to be used for the name.
    string prefix?;
    # Declares whether the property definition translates to an attribute instead of an element.
    boolean attribute?;
    # May be used only for an array definition.
    boolean wrapped?;
|};

# Defines a reference object.
public type Reference record {
    # Reference to a component
    string \$ref;
    # Short description of the target component
    string summary?;
    # Xml schema
    XmlSchema 'xml?;
    # Detailed description of the target component
    string description?;
};

# Defines a OpenAPI schema.
public type Schema PrimitiveTypeSchema|ArraySchema|ObjectSchema|OneOfSchema|AllOfSchema|AnyOfSchema|NotSchema|Reference;

# Describes a single request body.
public type RequestBody record {
    # A brief description of the request body. This could contain examples of use.
    string description?;
    # The content of the request body. 
    map<MediaType> content;
    # Whether the request body is mandatory in the request.
    boolean required?;
};

# Describes a single API operation on a path.
public type Operation record {
    # A list of tags for API documentation control
    string[] tags?;
    # A short summary of what the operation does
    string summary?;
    # A description explanation of the operation behavior
    string description?;
    # Operation ID for referencing the operation
    string operationId?;
    # A list of parameters that are applicable for this operation
    (Parameter|Reference)[] parameters?;
    # The request body applicable for this operation
    RequestBody|Reference requestBody?;
    # The list of possible responses as they are returned from executing this operation
    map<Response|Reference> responses?;
};

# Describes the responses from an API Operation.
public type Responses record {|
    # Default response for the API Operation
    Response|Reference default?;
    Response|Reference...;
|};

# Describes a single response from an API Operation.
public type Response record {
    # A short description of the response
    string description?;
    # A map containing schema of the response headers
    map<Header|Reference> headers?;
    # A map containing the structure of the response body
    map<MediaType> content?;
    # Not allowed $ref
    never \$ref?;
};

# Describes a single operation parameter.
public type Parameter record {
    # Name of the parameter
    string name;
    # The location of the parameter
    ParameterLocation 'in;
    # Whether the parameter is mandatory
    boolean required?;
    # A brief description of the parameter
    string description?;
    # Whether empty value is allowed
    boolean allowEmptyValue?;
    # Describes how a specific property value will be serialized depending on its type
    EncodingStyle style?;
    # When this is true, property values of type array or object generate separate parameters for each value of the array, or key-value-pair of the map
    boolean explode?;
    # Schema of the parameter
    Schema schema?;
    # Content of the parameter
    map<MediaType> content?;
    # Null value is allowed
    boolean nullable?;
};

# OpenAPI Specification 3.1.0
public type OpenApiSpec record {
    # OpenAPI version
    string openapi;
    # Server information
    Server[] servers?;
    # Server resource definitions
    Paths paths?;
    # Reference objects
    Components components?;
};

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

# Represents a request message for the chat service.
#
# + sessionId - A unique identifier for the chat session.
# + message - The content of the chat message sent by the user.
public type ChatReqMessage record {|
    string sessionId;
    string message;
|};

# Represents a response message from the chat service.
#
# + message - The response message generated by the chat service.
public type ChatRespMessage record {|
    string message;
|};

# Represents the configuration for a chat client.
public type ChatClientConfiguration record {|
    *http:ClientConfiguration;
|};

# Defines a chat service interface that handles incoming chat messages.
public type ChatService distinct service object {
    *http:Service;
    resource function post chat(@http:Payload ChatReqMessage request) returns ChatRespMessage|error;
};

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
import wso2/ai.agent;

configurable string wifiAPIUrl = ?;
configurable string wifiTokenUrl = ?;
configurable string wifiClientId = ?;
configurable string wifiClientSecret = ?;

configurable string apiKey = ?;
configurable string deploymentId = ?;
configurable string apiVersion = ?;
configurable string serviceUrl = ?;

const string OPENAPI_PATH = "openapi.json";

const string DEFAULT_QUERY = "create a new guest wifi with user openAPIwifi and password abc123 and show available accounts";

public function main(string openAPIPath = OPENAPI_PATH, string query = DEFAULT_QUERY) returns error? {

    // 1) Create the model (brain of the agent)
    agent:AzureChatGptModel model = check new ({auth: {apiKey}}, serviceUrl, deploymentId, apiVersion);

    // 2) Extract tools from openAPI specification
    final agent:HttpApiSpecification apiSpecification = check agent:extractToolsFromOpenApiSpecFile(openAPIPath);

    // 3) Createn httpToolKit with the extract tools from openAPI specification
    agent:HttpServiceToolKit toolKit = check new (wifiAPIUrl, apiSpecification.tools, {
        auth: {
            tokenUrl: wifiTokenUrl,
            clientId: wifiClientId,
            clientSecret: wifiClientSecret
        }
    });

    // 3) Create the agent
    agent:ReActAgent agent = check new (model, toolKit);

    // 4) Execute the user's query
    _ = agent:run(agent, query, context = {"email": "johnw@gmail.com"});

}

// Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

public type OrderItem record {|
    string category;
    string code;
    int qty;
|};

public type Order record {|
    string id;
    string name;
    OrderItem[] items;
|};

public type UpdateOrder record {|
    string name;
    OrderItem[] items;
|};

public type OrderCreated record {|
    *http:Created;
|};

public type OrderUpdated record {|
    *http:Ok;
|};

public type OrderNotFound record {|
    *http:BadRequest;
|};

public type OrderCanceled record {|
    *http:Ok;
|};

public enum InventoryOperation {
    INCREASE = "increase",
    DECREASE = "decrease"
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/lang.regexp;
import ballerina/log;

type ToolInfo readonly & record {|
    string toolList;
    string toolIntro;
|};

# A ReAct Agent that uses ReAct prompt to answer questions by using tools.
public isolated client class ReActAgent {
    *BaseAgent;
    final string instructionPrompt;
    # ToolStore instance to store the tools used by the agent
    public final ToolStore toolStore;
    # LLM model instance to be used by the agent (Can be either CompletionLlmModel or ChatLlmModel)
    public final Model model;
    # The memory associated with the agent.
    public final MemoryManager memoryManager;

    # Initialize an Agent.
    #
    # + model - LLM model instance
    # + tools - Tools to be used by the agent
    public isolated function init(Model model, (BaseToolKit|ToolConfig|FunctionTool)[] tools,
            MemoryManager memoryManager = new DefaultMessageWindowChatMemoryManager()) returns Error? {
        self.toolStore = check new (...tools);
        self.model = model;
        self.memoryManager = memoryManager;
        self.instructionPrompt = constructReActPrompt(extractToolInfo(self.toolStore));
        log:printDebug("Instruction Prompt Generated Successfully", instructionPrompt = self.instructionPrompt);
    }

    # Parse the ReAct llm response and extract the tool to be executed.
    #
    # + llmResponse - Raw LLM response
    # + return - A record containing the tool decided by the LLM, chat response or an error if the response is invalid
    public isolated function parseLlmResponse(json llmResponse)
        returns LlmToolResponse|LlmChatResponse|LlmInvalidGenerationError =>
        parseReActLlmResponse(normalizeLlmResponse(llmResponse.toString()));

    # Use LLM to decide the next tool/step based on the ReAct prompting.
    #
    # + progress - Execution progress with the current query and execution history
    # + memoryId - The ID associated with the agent memory
    # + return - LLM response containing the tool or chat response (or an error if the call fails)
    public isolated function selectNextTool(ExecutionProgress progress, string memoryId = DEFAULT_MEMORY_ID) returns json|LlmError {
        ChatMessage[] messages = [];
        // include the history
        foreach ExecutionStep step in progress.history {
            LlmToolResponse|LlmChatResponse|LlmInvalidGenerationError res = self.parseLlmResponse(step.llmResponse);
            if res is LlmInvalidGenerationError {
                messages.push({role: ASSISTANT, content: step.llmResponse.toJsonString()});
            } else if res is LlmChatResponse {
                messages.push({
                    role: ASSISTANT,
                    content: res.content
                });
            } else {
                messages.push(
                {role: ASSISTANT, function_call: {name: res.name, arguments: res.arguments.toJsonString(), id: res.id}},
                {role: FUNCTION, name: res.name, content: getObservationString(step.observation), id: res.id});
            }
        }

        Memory|MemoryError memory = self.memoryManager.getMemory(memoryId);
        ChatMessage[]|MemoryError additionalMessages = memory is Memory ? memory.get() : memory;
        if additionalMessages is error {
            log:printError("Failed to get chat messages from memory", additionalMessages);
        } else {
            messages.unshift(...additionalMessages);
        }
        return self.generate(messages);
    }

    # + messages - Chat history to be processed by the ReAct agent
    # + return - The processed chat history
    isolated function generate(ChatMessage[] messages) returns json|LlmError {
        ChatAssistantMessage[] assistantMessages = check self.model->chat(messages, stop = OBSERVATION_KEY);
        return assistantMessages[0].content is string ? assistantMessages[0].content : assistantMessages[0]?.function_call;
    }

    # Execute the agent for a given user's query.
    #
    # + query - Natural langauge commands to the agent  
    # + maxIter - No. of max iterations that agent will run to execute the task (default: 5)
    # + context - Context values to be used by the agent to execute the task
    # + verbose - If true, then print the reasoning steps (default: true)
    # + memoryId - The ID associated with the agent memory
    # + return - Returns the execution steps tracing the agent's reasoning and outputs from the tools
    isolated remote function run(string query, int maxIter = 5, string|map<json> context = {},
            boolean verbose = true, string memoryId = DEFAULT_MEMORY_ID)
        returns record {|(ExecutionResult|ExecutionError)[] steps; string answer?;|} {
        return run(self, query, maxIter, context, verbose, memoryId);
    }
}

isolated function normalizeLlmResponse(string llmResponse) returns string {
    string normalizedResponse = llmResponse.trim();
    if !normalizedResponse.includes(BACKTICKS) {
        if normalizedResponse.startsWith("{") && normalizedResponse.endsWith("}") {
            normalizedResponse = string `${BACKTICKS}${normalizedResponse}${BACKTICKS}`;
        } else {
            int? jsonStart = normalizedResponse.indexOf("{");
            int? jsonEnd = normalizedResponse.lastIndexOf("}");
            if jsonStart is int && jsonEnd is int {
                normalizedResponse = string `${BACKTICKS}${normalizedResponse.substring(jsonStart, jsonEnd + 1)}${BACKTICKS}`;
            }
        }
    }
    normalizedResponse = regexp:replace(re `${BACKTICKS}json`, normalizedResponse, BACKTICKS); // replace ```json  
    normalizedResponse = regexp:replaceAll(re `"\{\}"`, normalizedResponse, "{}"); // replace "{}"
    return normalizedResponse;
}

isolated function parseReActLlmResponse(string llmResponse) returns LlmToolResponse|LlmChatResponse|LlmInvalidGenerationError {
    string[] content = regexp:split(re `${BACKTICKS}`, llmResponse + "<endtoken>");
    if content.length() < 3 {
        log:printWarn("Unexpected LLM response is given", llmResponse = llmResponse);
        return error LlmInvalidGenerationError("Unable to extract the tool due to invalid generation", llmResponse = llmResponse, instruction = "Tool execution failed due to invalid generation.");
    }

    map<json>|error jsonResponse = content[1].fromJsonStringWithType();
    if jsonResponse is error {
        log:printWarn("Invalid JSON is given as the action.", jsonResponse);
        return error LlmInvalidGenerationError("Invalid JSON is given as the action.", jsonResponse, llmResponse = llmResponse, instruction = "Tool execution failed due to an invalid 'Action' JSON_BLOB.");
    }

    map<json> jsonAction = {};
    foreach [string, json] [key, value] in jsonResponse.entries() {
        if key.toLowerAscii() == ACTION_KEY {
            jsonAction[ACTION_NAME_KEY] = value;
        } else if key.toLowerAscii().matches(ACTION_INPUT_REGEX) {
            jsonAction[ACTION_ARGUEMENTS_KEY] = value;
        }
    }
    json input = jsonAction[ACTION_ARGUEMENTS_KEY];
    if jsonAction[ACTION_NAME_KEY].toString().toLowerAscii().matches(FINAL_ANSWER_REGEX) && input is string {
        return {
            content: input
        };
    }
    LlmToolResponse|error tool = jsonAction.fromJsonWithType();
    if tool is error {
        log:printError("Error while extracting action name and inputs from LLM response.", tool, llmResponse = llmResponse);
        return error LlmInvalidGenerationError("Generated 'Action' JSON_BLOB contains invalid action name or inputs.", tool, llmResponse = llmResponse, instruction = "Tool execution failed due to an invalid schema for 'Action' JSON_BLOB.");
    }

    return {
        name: tool.name,
        arguments: tool.arguments
    };
}

isolated function constructHistoryPrompt(ExecutionStep[] history) returns string {
    string historyPrompt = "";
    foreach ExecutionStep step in history {
        string observationStr = getObservationString(step.observation);
        string llmResponseStr = step.llmResponse.toString();
        historyPrompt += string `${llmResponseStr}${"\n"}${OBSERVATION_KEY}: ${observationStr}${"\n"}`;
    }
    return historyPrompt;
}

# Generate descriptions for the tools registered.
#
# + toolStore - ToolStore instance
# + return - Return a record with tool names and descriptions
isolated function extractToolInfo(ToolStore toolStore) returns ToolInfo {
    string[] toolNameList = [];
    string[] toolIntroList = [];
    foreach AgentTool tool in toolStore.tools {
        toolNameList.push(string `${tool.name}`);
        record {|string description; JsonInputSchema inputSchema?;|} toolDescription = {
            description: tool.description,
            inputSchema: tool.variables
        };
        toolIntroList.push(string `${tool.name}: ${toolDescription.toString()}`);
    }
    return {
        toolList: string:'join(", ", ...toolNameList).trim(),
        toolIntro: string:'join("\n", ...toolIntroList).trim()
    };
}

isolated function constructReActPrompt(ToolInfo toolInfo) returns string => string `System: Respond to the human as helpfully and accurately as possible. You have access to the following tools:

${toolInfo.toolIntro}

Use a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).

Valid "action" values: "Final Answer" or ${toolInfo.toolList}

Provide only ONE action per $JSON_BLOB, as shown:

${BACKTICKS}
{
  "action": $TOOL_NAME,
  "action_input": $INPUT_JSON
}
${BACKTICKS}

Follow this format:

Question: input question to answer
Thought: consider previous and subsequent steps
Action:
${BACKTICKS}
$JSON_BLOB
${BACKTICKS}
Observation: action result
... (repeat Thought/Action/Observation N times)
Thought: I know what to respond
Action:
${BACKTICKS}
{
  "action": "Final Answer",
  "action_input": "Final response to human"
}
${BACKTICKS}

Begin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if appropriate. Format is Action:${BACKTICKS}$JSON_BLOB${BACKTICKS}then Observation:.`;

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

service / on new http:Listener(9090) {
    resource function post chat/completions(map<json> payload) returns ChatCompletionResponse {
        AssistantMessage message = {
            role: "assistant",
            toolCalls: (),
            content: "Test message received! How can I assist you today?",
            prefix: false
        };

        ChatCompletionChoice choice = {
            finishReason: "stop",
            index: 0,
            message: message
        };

        return {
            id: "cmpl-e5cc70bb28c444948073e77776eb30ef",
            model: "gpt-4o-mini-2024-07-18",
            'object: "chat.completion",
            usage: {completionTokens: 16, promptTokens: 34, totalTokens: 50},
            choices: [
                choice
            ],
            created: 1702256327
        };
    }
};

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;
import ballerinax/ai.agent;

configurable string apiKey = ?;
configurable string deploymentId = ?;
configurable string apiVersion = ?;
configurable string serviceUrl = ?;

final agent:Model model = check new agent:AzureOpenAiModel(serviceUrl, apiKey, deploymentId, apiVersion);
final agent:Agent agent = check new (
    systemPrompt = {
        role: "Math Tutor",
        instructions: "You are a school tutor assistant. " +
        "Provide answers to students' questions so they can compare their answers. " +
        "Use the tools when there is query related to math"
    },
    model = model,
    tools = [sum, mult, sqrt],
    verbose = true
);

@agent:Tool
isolated function sum(decimal a, decimal b) returns decimal => a + b;

@agent:Tool
isolated function mult(decimal a, decimal b) returns decimal => a * b;

@agent:Tool
isolated function sqrt(float a) returns float => a.sqrt();

service /api/v1 on new agent:Listener(9090) {
    resource function post chat(@http:Payload agent:ChatReqMessage request) returns agent:ChatRespMessage|error {
        string response = check agent->run(request.message, memoryId = request.sessionId);
        return {message: response};
    }
}

// Copyright (c) 2018 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// NOTE: All the tokens/credentials used in this test are dummy tokens/credentials and used only for testing purposes.

import ballerina/test;

@test:Config {}
isolated function testClientJwtAuthProviderSuccess() returns Error? {
    IssuerConfig jwtConfig = {
        username: "admin",
        issuer: "wso2",
        audience: ["ballerina"],
        signatureConfig: {
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    ClientSelfSignedJwtAuthProvider jwtAuthProvider = new(jwtConfig);
    string result = check jwtAuthProvider.generateToken();
    test:assertTrue(result.startsWith("eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QifQ"));
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerinax/ai.agent;

@agent:Tool
isolated function toolWithString(string param) => ();

@agent:Tool
isolated function toolWithInt(int param) => ();

@agent:Tool
isolated function toolWithFloat(float param) => ();

@agent:Tool
isolated function toolWithDecimal(decimal param) => ();

@agent:Tool
isolated function toolWithByte(byte param) => ();

@agent:Tool
isolated function toolWithBoolean(boolean param) => ();

@agent:Tool
isolated function toolWithJson(json param) => ();

@agent:Tool
isolated function toolWithJsonMap(map<json> param) => ();

@agent:Tool
isolated function toolWithStringArray(string[] param) => ();

@agent:Tool
isolated function toolWithByteArray(byte[] param) => ();

@agent:Tool
isolated function toolWithRecord(User user) => ();

@agent:Tool
isolated function toolWithTable(table<User> users) => ();

@agent:Tool
isolated function toolWithEnum(Status staus) => ();

// The generated schema should not have `param` as required field
@agent:Tool
isolated function toolWithDefaultParam(string param = "default") => ();

@agent:Tool
isolated function toolWithUnion(string|int|float|decimal|boolean|byte|Status|User|json|map<json>|table<User> param) => ();

@agent:Tool
isolated function toolWithTypeAlias(Data data) => ();

@agent:Tool
isolated function toolWithIncludedRecord(*Person person) => ();

@agent:Tool
isolated function toolWithMultipleParams(int a, string b, decimal c, float d, User e,
        table<User> f, User[] g, Data h = ()) => ();

# Tool description 
# + person - First parameter description
# + salary - Second parameter description
@agent:Tool
isolated function toolWithDocumentation(Person person, decimal salary) => ();

# Tool description 
# + person - First parameter description
# + salary - Second parameter description
@agent:Tool {
    name: "overriddenFunctionName"
}
isolated function toolWithOverriddenFunctionName(Person person, decimal salary) => ();

# Tool description 
# + person - First parameter description
# + salary - Second parameter description
@agent:Tool {
    description: "overridden description"
}
isolated function toolWithOverriddenDescription(Person person, decimal salary) => ();

# Tool description 
# + person - First parameter description
# + salary - Second parameter description
@agent:Tool {
    parameters: {
        properties: {
            person: {'type: "string"}
        },
        required: ["person"]
    }
}
isolated function toolWithOverriddenParameterSchema(Person person, decimal salary) => ();

# Tool description 
# + person - First parameter description
# + salary - Second parameter description
@agent:Tool {
    parameters: {
        properties: {
            person: {'type: "string"}
        },
        required: ["person"]
    },
    name: "overriddenName",
    description: "overridden description"
}
isolated function toolWithOverriddenConfig(Person person, decimal salary) => ();

// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/constraint;
import ballerina/data.jsondata;
import ballerina/http;

# Represents the Queries record for the operation: jobs_api_routes_fine_tuning_create_fine_tuning_job
public type JobsApiRoutesFineTuningCreateFineTuningJobQueries record {
    @http:Query {name: "dry_run"}
    boolean? dryRun?;
};

public type ToolCall record {|
    FunctionCall 'function;
    int index = 0;
    string id = "null";
    ToolTypes 'type?;
|};

public type JsonSchema record {|
    record {} schema;
    string name;
    string? description?;
    boolean strict = false;
|};

public type ChatCompletionChoice record {
    @jsondata:Name {value: "finish_reason"}
    "stop"|"length"|"model_length"|"error"|"tool_calls" finishReason;
    int index;
    AssistantMessage message;
};

public type OCRResponse record {|
    # List of OCR info for pages.
    OCRPageObject[] pages;
    # The model used to generate the OCR.
    string model;
    @jsondata:Name {value: "usage_info"}
    OCRUsageInfo usageInfo;
|};

public type ArchiveFTModelOut record {
    boolean archived = true;
    string id;
    "model" 'object = "model";
};

public type EventOut record {
    record {}? data?;
    # The name of the event.
    string name;
    @jsondata:Name {value: "created_at"}
    int createdAt;
};

public type GithubRepositoryIn record {
    string owner;
    string? ref?;
    string name;
    @constraint:Number {minValueExclusive: 0}
    decimal weight = 1;
    "github" 'type = "github";
    string token;
};

# Represents the Queries record for the operation: jobs_api_routes_fine_tuning_get_fine_tuning_jobs
public type JobsApiRoutesFineTuningGetFineTuningJobsQueries record {
    @http:Query {name: "wandb_project"}
    string? wandbProject?;
    @http:Query {name: "wandb_name"}
    string? wandbName?;
    @http:Query {name: "created_after"}
    string? createdAfter?;
    # The model name used for fine-tuning to filter on. When set, the other results are not displayed.
    string? model?;
    # The page number of the results to be returned.
    int page = 0;
    # The model suffix to filter on. When set, the other results are not displayed.
    string? suffix?;
    @http:Query {name: "created_by_me"}
    boolean createdByMe = false;
    @http:Query {name: "page_size"}
    int pageSize = 100;
    # The current job state to filter on. When set, the other results are not displayed.
    "QUEUED"|"STARTED"|"VALIDATING"|"VALIDATED"|"RUNNING"|"FAILED_VALIDATION"|"FAILED"|"SUCCESS"|"CANCELLED"|"CANCELLATION_REQUESTED"? status?;
};

public type FileSchema record {
    # The name of the uploaded file.
    string filename;
    FilePurpose purpose;
    # The size of the file, in bytes.
    int bytes;
    @jsondata:Name {value: "created_at"}
    int createdAt;
    # The unique identifier of the file.
    string id;
    Source 'source;
    @jsondata:Name {value: "sample_type"}
    SampleType sampleType;
    @jsondata:Name {value: "num_lines"}
    int? numLines?;
    # The object type, which is always "file".
    string 'object;
};

# The fine-tuning hyperparameter settings used in a fine-tune job.
public type TrainingParametersIn record {
    @jsondata:Name {value: "fim_ratio"}
    decimal? fimRatio = 0.9;
    @jsondata:Name {value: "weight_decay"}
    decimal? weightDecay = 0.1;
    @jsondata:Name {value: "training_steps"}
    int? trainingSteps?;
    @jsondata:Name {value: "learning_rate"}
    decimal learningRate = 0.00010;
    decimal? epochs?;
    @jsondata:Name {value: "seq_len"}
    int? seqLen?;
    @jsondata:Name {value: "warmup_fraction"}
    decimal? warmupFraction = 0.05;
};

# Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint.
@display {label: "Connection Config"}
public type ConnectionConfig record {|
    # Configurations related to client authentication
    http:BearerTokenConfig auth;
    # The HTTP version understood by the client
    http:HttpVersion httpVersion = http:HTTP_2_0;
    # Configurations related to HTTP/1.x protocol
    http:ClientHttp1Settings http1Settings?;
    # Configurations related to HTTP/2 protocol
    http:ClientHttp2Settings http2Settings?;
    # The maximum time to wait (in seconds) for a response before closing the connection
    decimal timeout = 60;
    # The choice of setting `forwarded`/`x-forwarded` header
    string forwarded = "disable";
    # Configurations associated with request pooling
    http:PoolConfiguration poolConfig?;
    # HTTP caching related configurations
    http:CacheConfig cache?;
    # Specifies the way of handling compression (`accept-encoding`) header
    http:Compression compression = http:COMPRESSION_AUTO;
    # Configurations associated with the behaviour of the Circuit Breaker
    http:CircuitBreakerConfig circuitBreaker?;
    # Configurations associated with retrying
    http:RetryConfig retryConfig?;
    # Configurations associated with inbound response size limits
    http:ResponseLimitConfigs responseLimits?;
    # SSL/TLS-related options
    http:ClientSecureSocket secureSocket?;
    # Proxy server related options
    http:ProxyConfig proxy?;
    # Enables the inbound payload validation functionality which provided by the constraint package. Enabled by default
    boolean validation = true;
    # Enables relaxed data binding on the client side. When enabled, `nil` values are treated as optional, 
    # and absent fields are handled as `nilable` types. Enabled by default.
    boolean laxDataBinding = true;
|};

public type FTModelCapabilitiesOut record {
    @jsondata:Name {value: "completion_chat"}
    boolean completionChat = true;
    @jsondata:Name {value: "function_calling"}
    boolean functionCalling = false;
    @jsondata:Name {value: "fine_tuning"}
    boolean fineTuning = false;
    @jsondata:Name {value: "completion_fim"}
    boolean completionFim = false;
};

public type ResponseFormat record {|
    @jsondata:Name {value: "json_schema"}
    JsonSchema jsonSchema?;
    ResponseFormats 'type?;
|};

public type UnarchiveFTModelOut record {
    boolean archived = false;
    string id;
    "model" 'object = "model";
};

public type TextChunk record {|
    string text;
    "text" 'type = "text";
|};

public type WandbIntegrationOut record {
    # A display name to set for the run. If not set, will use the job ID as the name.
    string? name?;
    # The name of the project that the new run will be created under.
    string project;
    "wandb" 'type = "wandb";
    @jsondata:Name {value: "run_name"}
    string? runName?;
};

public type ChatCompletionResponse record {
    *ChatCompletionResponseBase;
    ChatCompletionChoice[] choices?;
    string id;
    string model;
    string 'object;
    UsageInfo usage;
};

public type FTModelOut record {
    boolean archived;
    FTModelCapabilitiesOut capabilities;
    string[] aliases = [];
    @jsondata:Name {value: "max_context_length"}
    int maxContextLength = 32768;
    int created;
    string root;
    string? name?;
    string? description?;
    @jsondata:Name {value: "owned_by"}
    string ownedBy;
    string id;
    string job;
    "model" 'object = "model";
};

public type TrainingFile record {
    @jsondata:Name {value: "file_id"}
    string fileId;
    @constraint:Number {minValueExclusive: 0}
    decimal weight = 1;
};

public type ClassificationRequest record {|
    # Text to classify.
    string|string[] input;
    # ID of the model to use.
    string model;
|};

# An object specifying the format that the model must output. Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is in JSON. When using JSON mode you MUST also instruct the model to produce JSON yourself with a system or a user message.
public type ResponseFormats "text"|"json_object"|"json_schema";

public type ContentChunk TextChunk|ImageURLChunk|DocumentURLChunk|ReferenceChunk;

public type MultiPartBodyParams record {
    # The File object (not file name) to be uploaded.
    #  To upload a file and specify a custom file name you should format your request as such:
    #  ```bash
    #  file=@path/to/your/file.jsonl;filename=custom_name.jsonl
    #  ```
    #  Otherwise, you can just keep the original file name:
    #  ```bash
    #  file=@path/to/your/file.jsonl
    #  ```
    record {byte[] fileContent; string fileName;} file;
    FilePurpose purpose?;
};

public type ChatCompletionResponseBase record {
    *ResponseBase;
    int created?;
};

public type ApiEndpoint "/chat/completions"|"/embeddings"|"/fim/completions"|"/moderations"|"/chat/moderations";

public type BatchJobStatus "QUEUED"|"RUNNING"|"SUCCESS"|"FAILED"|"TIMEOUT_EXCEEDED"|"CANCELLATION_REQUESTED"|"CANCELLED";

public type FIMCompletionResponse record {
    *ChatCompletionResponse;
    string model?;
};

public type DeleteModelOut record {
    # The deletion status
    boolean deleted = true;
    # The ID of the deleted model.
    string id;
    # The object type that was deleted
    string 'object = "model";
};

public type OCRUsageInfo record {|
    @jsondata:Name {value: "pages_processed"}
    int pagesProcessed;
    @jsondata:Name {value: "doc_size_bytes"}
    int? docSizeBytes?;
|};

public type DetailedJobOut record {
    @jsondata:Name {value: "job_type"}
    string jobType;
    JobMetadataOut metadata?;
    @jsondata:Name {value: "fine_tuned_model"}
    string? fineTunedModel?;
    @jsondata:Name {value: "created_at"}
    int createdAt;
    CheckpointOut[] checkpoints = [];
    string? suffix?;
    @jsondata:Name {value: "auto_start"}
    boolean autoStart;
    @jsondata:Name {value: "training_files"}
    string[] trainingFiles;
    (GithubRepositoryOut)[] repositories = [];
    TrainingParameters hyperparameters;
    FineTuneableModel model;
    string id;
    @jsondata:Name {value: "trained_tokens"}
    int? trainedTokens?;
    @jsondata:Name {value: "modified_at"}
    int modifiedAt;
    (WandbIntegrationOut)[]? integrations?;
    # Event items are created every time the status of a fine-tuning job changes. The timestamped list of all events is accessible here.
    EventOut[] events = [];
    "QUEUED"|"STARTED"|"VALIDATING"|"VALIDATED"|"RUNNING"|"FAILED_VALIDATION"|"FAILED"|"SUCCESS"|"CANCELLED"|"CANCELLATION_REQUESTED" status;
    @jsondata:Name {value: "validation_files"}
    string[]? validationFiles = [];
    "job" 'object = "job";
};

public type OCRPageDimensions record {|
    # Width of the image in pixels
    @constraint:Int {minValue: 0}
    int width;
    # Dots per inch of the page-image
    @constraint:Int {minValue: 0}
    int dpi;
    # Height of the image in pixels
    @constraint:Int {minValue: 0}
    int height;
|};

public type UpdateFTModelIn record {
    string? name?;
    string? description?;
};

public type ResponseBase record {
    UsageInfo usage?;
    string model?;
    string id?;
    string 'object?;
};

public type ClassificationResponse record {
    string model?;
    string id?;
    ClassificationObject[] results?;
};

public type FunctionCall record {|
    string name;
    record {}|string arguments;
|};

public type UsageInfo record {
    @jsondata:Name {value: "completion_tokens"}
    int completionTokens;
    @jsondata:Name {value: "prompt_tokens"}
    int promptTokens;
    @jsondata:Name {value: "total_tokens"}
    int totalTokens;
};

# Metrics at the step number during the fine-tuning job. Use these metrics to assess if the training is going smoothly (loss should decrease, token accuracy should increase).
public type MetricOut record {
    @jsondata:Name {value: "valid_loss"}
    decimal? validLoss?;
    @jsondata:Name {value: "valid_mean_token_accuracy"}
    decimal? validMeanTokenAccuracy?;
    @jsondata:Name {value: "train_loss"}
    decimal? trainLoss?;
};

public type UploadFileOut record {
    # The name of the uploaded file.
    string filename;
    FilePurpose purpose;
    # The size of the file, in bytes.
    int bytes;
    @jsondata:Name {value: "created_at"}
    int createdAt;
    # The unique identifier of the file.
    string id;
    Source 'source;
    @jsondata:Name {value: "sample_type"}
    SampleType sampleType;
    @jsondata:Name {value: "num_lines"}
    int? numLines?;
    # The object type, which is always "file".
    string 'object;
};

public type BatchJobIn record {
    @jsondata:Name {value: "input_files"}
    string[] inputFiles;
    ApiEndpoint endpoint;
    record {|string...;|}? metadata?;
    @jsondata:Name {value: "timeout_hours"}
    int timeoutHours = 24;
    string model;
};

public type BatchError record {
    int count = 1;
    string message;
};

public type JobsOut record {
    int total;
    JobOut[] data = [];
    "list" 'object = "list";
};

# Represents the Queries record for the operation: files_api_routes_list_files
public type FilesApiRoutesListFilesQueries record {
    string? search?;
    FilePurpose purpose?;
    int page = 0;
    Source[]? 'source?;
    @http:Query {name: "sample_type"}
    SampleType[]? sampleType?;
    @http:Query {name: "page_size"}
    int pageSize = 100;
};

public type ReferenceChunk record {|
    @jsondata:Name {value: "reference_ids"}
    int[] referenceIds;
    "reference" 'type = "reference";
|};

# Provides settings related to HTTP/1.x protocol.
public type ClientHttp1Settings record {|
    # Specifies whether to reuse a connection for multiple requests
    http:KeepAlive keepAlive = http:KEEPALIVE_AUTO;
    # The chunking behaviour of the request
    http:Chunking chunking = http:CHUNKING_AUTO;
    # Proxy server related options
    ProxyConfig proxy?;
|};

public type OCRImageObject record {|
    @jsondata:Name {value: "bottom_right_x"}
    int? bottomRightX;
    @jsondata:Name {value: "bottom_right_y"}
    int? bottomRightY;
    @jsondata:Name {value: "image_base64"}
    string? imageBase64?;
    @jsondata:Name {value: "top_left_y"}
    int? topLeftY;
    # Image ID for extracted image in a page
    string id;
    @jsondata:Name {value: "top_left_x"}
    int? topLeftX;
|};

public type SampleType "pretrain"|"instruct"|"batch_request"|"batch_result"|"batch_error";

public type OCRRequest record {|
    # Specific pages user wants to process in various formats: single number, range, or list of both. Starts from 0
    int[]? pages?;
    @jsondata:Name {value: "image_min_size"}
    int? imageMinSize?;
    # Document to run OCR on
    DocumentURLChunk|ImageURLChunk document;
    @jsondata:Name {value: "include_image_base64"}
    boolean? includeImageBase64?;
    @jsondata:Name {value: "image_limit"}
    int? imageLimit?;
    string? model;
    string id?;
|};

# Represents the Queries record for the operation: jobs_api_routes_batch_get_batch_jobs
public type JobsApiRoutesBatchGetBatchJobsQueries record {
    record {}? metadata?;
    @http:Query {name: "created_after"}
    string? createdAfter?;
    string? model?;
    int page = 0;
    @http:Query {name: "created_by_me"}
    boolean createdByMe = false;
    @http:Query {name: "page_size"}
    int pageSize = 100;
    BatchJobStatus status?;
};

public type FilePurpose "fine-tune"|"batch";

public type LegacyJobMetadataOut record {
    @jsondata:Name {value: "data_tokens"}
    int? dataTokens?;
    @jsondata:Name {value: "train_tokens_per_step"}
    int? trainTokensPerStep?;
    # The cost of the fine-tuning job.
    decimal? cost?;
    @jsondata:Name {value: "cost_currency"}
    string? costCurrency?;
    @jsondata:Name {value: "estimated_start_time"}
    int? estimatedStartTime?;
    @jsondata:Name {value: "expected_duration_seconds"}
    int? expectedDurationSeconds?;
    boolean deprecated = true;
    string details;
    @jsondata:Name {value: "train_tokens"}
    int? trainTokens?;
    # The number of complete passes through the entire training dataset.
    decimal? epochs?;
    @jsondata:Name {value: "training_steps"}
    int? trainingSteps?;
    "job.metadata" 'object = "job.metadata";
};

# this restriction of `Function` is used to select a specific function to call
public type FunctionName record {|
    string name;
|};

public type DeleteFileOut record {
    # The deletion status.
    boolean deleted;
    # The ID of the deleted file.
    string id;
    # The object type that was deleted
    string 'object;
};

public type DocumentURLChunk record {|
    @jsondata:Name {value: "document_name"}
    string? documentName?;
    string 'type = "document_url";
    @jsondata:Name {value: "document_url"}
    string documentUrl;
|};

public type RetrieveFileOut record {
    # The name of the uploaded file.
    string filename;
    boolean deleted;
    FilePurpose purpose;
    # The size of the file, in bytes.
    int bytes;
    @jsondata:Name {value: "created_at"}
    int createdAt;
    # The unique identifier of the file.
    string id;
    Source 'source;
    @jsondata:Name {value: "sample_type"}
    SampleType sampleType;
    @jsondata:Name {value: "num_lines"}
    int? numLines?;
    # The object type, which is always "file".
    string 'object;
};

public type ToolMessage record {|
    "tool" role = "tool";
    @jsondata:Name {value: "tool_call_id"}
    string? toolCallId?;
    string? name?;
    string|ContentChunk[]? content;
|};

# Extra fields for fine-tuned models.
public type FTModelCard record {
    ModelCapabilities capabilities;
    string[] aliases = [];
    int created?;
    string? description?;
    @jsondata:Name {value: "owned_by"}
    string ownedBy = "mistralai";
    string? deprecation?;
    "fine-tuned" 'type = "fine-tuned";
    boolean archived = false;
    @jsondata:Name {value: "max_context_length"}
    int maxContextLength = 32768;
    string root;
    string? name?;
    @jsondata:Name {value: "default_model_temperature"}
    decimal? defaultModelTemperature?;
    string id;
    string job;
    string 'object = "model";
};

public type Tool record {|
    Function 'function;
    ToolTypes 'type?;
|};

public type BatchJobsOut record {
    int total;
    BatchJobOut[] data = [];
    "list" 'object = "list";
};

public type AssistantMessage record {|
    "assistant" role = "assistant";
    # Set this to `true` when adding an assistant message as prefix to condition the model response. The role of the prefix message is to force the model to start its answer by the content of the message.
    boolean prefix = false;
    @jsondata:Name {value: "tool_calls"}
    ToolCall[]? toolCalls?;
    string|ContentChunk[]? content?;
|};

public type Prediction record {|
    string 'type = "content";
    string content = "";
|};

public type GithubRepositoryOut record {
    string owner;
    string? ref?;
    string name;
    @constraint:Number {minValueExclusive: 0}
    decimal weight = 1;
    "github" 'type = "github";
    @jsondata:Name {value: "commit_id"}
    string commitId;
};

public type ImageURL record {|
    string? detail?;
    string url;
|};

public type ChatModerationRequest record {|
    @jsondata:Name {value: "truncate_for_context_length"}
    boolean truncateForContextLength = false;
    # Chat to classify
    (SystemMessage|UserMessage|AssistantMessage|ToolMessage)[]|(SystemMessage|UserMessage|AssistantMessage|ToolMessage)[][] input;
    string model;
|};

public type ModelCapabilities record {
    @jsondata:Name {value: "completion_chat"}
    boolean completionChat = true;
    @jsondata:Name {value: "function_calling"}
    boolean functionCalling = true;
    boolean vision = false;
    @jsondata:Name {value: "fine_tuning"}
    boolean fineTuning = false;
    @jsondata:Name {value: "completion_fim"}
    boolean completionFim = false;
};

public type EmbeddingResponseData record {
    int index?;
    decimal[] embedding?;
    string 'object?;
};

public type ListFilesOut record {
    int total;
    FileSchema[] data;
    string 'object;
};

public type ToolTypes "function";

public type OCRPageObject record {|
    # List of all extracted images in the page
    OCRImageObject[] images;
    # The markdown string response of the page
    string markdown;
    # The page index in a pdf document starting from 0
    @constraint:Int {minValue: 0}
    int index;
    OCRPageDimensions dimensions;
|};

public type FileSignedURL record {
    string url;
};

# ToolChoice is either a ToolChoiceEnum or a ToolChoice
public type ToolChoice record {|
    FunctionName 'function;
    ToolTypes 'type?;
|};

# The name of the model to fine-tune.
public type FineTuneableModel "open-mistral-7b"|"mistral-small-latest"|"codestral-latest"|"mistral-large-latest"|"open-mistral-nemo"|"ministral-3b-latest";

public type BaseModelCard record {
    ModelCapabilities capabilities;
    string[] aliases = [];
    @jsondata:Name {value: "max_context_length"}
    int maxContextLength = 32768;
    int created?;
    string? name?;
    @jsondata:Name {value: "default_model_temperature"}
    decimal? defaultModelTemperature?;
    string? description?;
    @jsondata:Name {value: "owned_by"}
    string ownedBy = "mistralai";
    string id;
    string? deprecation?;
    "base" 'type = "base";
    string 'object = "model";
};

public type WandbIntegration record {
    @jsondata:Name {value: "api_key"}
    string apiKey;
    # A display name to set for the run. If not set, will use the job ID as the name.
    string? name?;
    # The name of the project that the new run will be created under.
    string project;
    "wandb" 'type = "wandb";
    @jsondata:Name {value: "run_name"}
    string? runName?;
};

# Represents the Queries record for the operation: files_api_routes_get_signed_url
public type FilesApiRoutesGetSignedUrlQueries record {
    # Number of hours before the url becomes invalid. Defaults to 24h
    int expiry = 24;
};

public type FIMCompletionRequest record {|
    @jsondata:Name {value: "top_p"}
    decimal topP = 1;
    @jsondata:Name {value: "random_seed"}
    int? randomSeed?;
    # Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    string|string[] stop?;
    @jsondata:Name {value: "max_tokens"}
    int? maxTokens?;
    # Whether to stream back partial progress. If set, tokens will be sent as data-only server-side events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
    boolean 'stream = false;
    # What sampling temperature to use, we recommend between 0.0 and 0.7. Higher values like 0.7 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or `top_p` but not both. The default value varies depending on the model you are targeting. Call the `/models` endpoint to retrieve the appropriate value.
    decimal? temperature?;
    # ID of the model to use. Only compatible for now with:
    #   - `codestral-2405`
    #   - `codestral-latest`
    string model = "codestral-2405";
    # Optional text/code that adds more context for the model. When given a `prompt` and a `suffix` the model will fill what is between them. When `suffix` is not provided, the model will simply execute completion starting with `prompt`.
    string? suffix = "";
    # The text/code to complete.
    string prompt;
    @jsondata:Name {value: "min_tokens"}
    int? minTokens?;
|};

public type SystemMessage record {|
    "system" role = "system";
    string|TextChunk[] content;
|};

public type AgentsCompletionRequest record {|
    @jsondata:Name {value: "random_seed"}
    int? randomSeed?;
    @jsondata:Name {value: "agent_id"}
    string agentId;
    @jsondata:Name {value: "max_tokens"}
    int? maxTokens?;
    @jsondata:Name {value: "presence_penalty"}
    decimal presencePenalty = 0;
    Tool[]? tools?;
    # Number of completions to return for each request, input tokens are only billed once.
    int? n?;
    @jsondata:Name {value: "response_format"}
    ResponseFormat responseFormat?;
    @jsondata:Name {value: "frequency_penalty"}
    decimal frequencyPenalty = 0;
    # Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    string|string[] stop?;
    # Whether to stream back partial progress. If set, tokens will be sent as data-only server-side events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
    boolean 'stream = false;
    Prediction prediction?;
    # The prompt(s) to generate completions for, encoded as a list of dict with role and content.
    (SystemMessage|UserMessage|AssistantMessage|ToolMessage)[] messages;
    @jsondata:Name {value: "tool_choice"}
    ToolChoice|ToolChoiceEnum toolChoice = "auto";
|};

public type JobMetadataOut record {
    @jsondata:Name {value: "data_tokens"}
    int? dataTokens?;
    @jsondata:Name {value: "train_tokens_per_step"}
    int? trainTokensPerStep?;
    decimal? cost?;
    @jsondata:Name {value: "cost_currency"}
    string? costCurrency?;
    @jsondata:Name {value: "estimated_start_time"}
    int? estimatedStartTime?;
    @jsondata:Name {value: "expected_duration_seconds"}
    int? expectedDurationSeconds?;
    @jsondata:Name {value: "train_tokens"}
    int? trainTokens?;
};

public type UserMessage record {|
    "user" role = "user";
    string|ContentChunk[]? content;
|};

public type Source "upload"|"repository"|"mistral";

public type ChatCompletionRequest record {|
    @jsondata:Name {value: "random_seed"}
    int? randomSeed?;
    @jsondata:Name {value: "safe_prompt"}
    boolean safePrompt = false;
    @jsondata:Name {value: "max_tokens"}
    int? maxTokens?;
    @jsondata:Name {value: "presence_penalty"}
    decimal presencePenalty = 0;
    Tool[]? tools?;
    # Number of completions to return for each request, input tokens are only billed once.
    int? n?;
    @jsondata:Name {value: "top_p"}
    decimal topP = 1;
    @jsondata:Name {value: "response_format"}
    ResponseFormat responseFormat?;
    @jsondata:Name {value: "frequency_penalty"}
    decimal frequencyPenalty = 0;
    # Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
    string|string[] stop?;
    # Whether to stream back partial progress. If set, tokens will be sent as data-only server-side events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
    boolean 'stream = false;
    # What sampling temperature to use, we recommend between 0.0 and 0.7. Higher values like 0.7 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or `top_p` but not both. The default value varies depending on the model you are targeting. Call the `/models` endpoint to retrieve the appropriate value.
    decimal? temperature?;
    Prediction prediction?;
    # The prompt(s) to generate completions for, encoded as a list of dict with role and content.
    (SystemMessage|UserMessage|AssistantMessage|ToolMessage)[] messages;
    @jsondata:Name {value: "tool_choice"}
    ToolChoice|ToolChoiceEnum toolChoice = "auto";
    # ID of the model to use. You can use the [List Available Models](/api/#tag/models/operation/list_models_v1_models_get) API to see all of your available models, or see our [Model overview](/models) for model descriptions.
    string model;
|};

public type ModelList record {
    (BaseModelCard|FTModelCard)[] data?;
    string 'object = "list";
};

# {"type":"image_url","image_url":{"url":"data:image/png;base64,iVBORw0
public type ImageURLChunk record {|
    @jsondata:Name {value: "image_url"}
    ImageURL|string imageUrl;
    "image_url" 'type = "image_url";
|};

public type Function record {|
    string name;
    string description = "";
    boolean strict = false;
    record {} parameters;
|};

public type ToolChoiceEnum "auto"|"none"|"any"|"required";

public type TrainingParameters record {
    @jsondata:Name {value: "fim_ratio"}
    decimal? fimRatio = 0.9;
    @jsondata:Name {value: "weight_decay"}
    decimal? weightDecay = 0.1;
    @jsondata:Name {value: "training_steps"}
    int? trainingSteps?;
    @jsondata:Name {value: "learning_rate"}
    decimal learningRate = 0.00010;
    decimal? epochs?;
    @jsondata:Name {value: "seq_len"}
    int? seqLen?;
    @jsondata:Name {value: "warmup_fraction"}
    decimal? warmupFraction = 0.05;
};

public type Response\ Retrieve\ Model\ V1\ Models\ \ Model\ Id\ \ Get BaseModelCard|FTModelCard;

public type JobOut record {
    @jsondata:Name {value: "job_type"}
    string jobType;
    JobMetadataOut metadata?;
    @jsondata:Name {value: "fine_tuned_model"}
    string? fineTunedModel?;
    @jsondata:Name {value: "created_at"}
    int createdAt;
    # Optional text/code that adds more context for the model. When given a `prompt` and a `suffix` the model will fill what is between them. When `suffix` is not provided, the model will simply execute completion starting with `prompt`.
    string? suffix?;
    @jsondata:Name {value: "auto_start"}
    boolean autoStart;
    @jsondata:Name {value: "training_files"}
    string[] trainingFiles;
    (GithubRepositoryOut)[] repositories = [];
    TrainingParameters hyperparameters;
    FineTuneableModel model;
    # The ID of the job.
    string id;
    @jsondata:Name {value: "trained_tokens"}
    int? trainedTokens?;
    @jsondata:Name {value: "modified_at"}
    int modifiedAt;
    # A list of integrations enabled for your fine-tuning job.
    (WandbIntegrationOut)[]? integrations?;
    # The current status of the fine-tuning job.
    "QUEUED"|"STARTED"|"VALIDATING"|"VALIDATED"|"RUNNING"|"FAILED_VALIDATION"|"FAILED"|"SUCCESS"|"CANCELLED"|"CANCELLATION_REQUESTED" status;
    @jsondata:Name {value: "validation_files"}
    string[]? validationFiles = [];
    # The object type of the fine-tuning job.
    "job" 'object = "job";
};

public type JobIn record {
    @jsondata:Name {value: "training_files"}
    TrainingFile[] trainingFiles = [];
    @constraint:Array {maxLength: 50}
    (GithubRepositoryIn)[] repositories = [];
    TrainingParametersIn hyperparameters;
    FineTuneableModel model;
    # A string that will be added to your fine-tuning model name. For example, a suffix of "my-great-model" would produce a model name like `ft:open-mistral-7b:my-great-model:xxx...`
    string? suffix?;
    # A list of integrations to enable for your fine-tuning job.
    (WandbIntegration)[]? integrations?;
    @jsondata:Name {value: "validation_files"}
    string[]? validationFiles?;
    @jsondata:Name {value: "auto_start"}
    boolean autoStart?;
};

# Proxy server configurations to be used with the HTTP client endpoint.
public type ProxyConfig record {|
    # Host name of the proxy server
    string host = "";
    # Proxy server port
    int port = 0;
    # Proxy server username
    string userName = "";
    # Proxy server password
    @display {label: "", kind: "password"}
    string password = "";
|};

public type EmbeddingRequest record {|
    # Text to embed.
    string|string[] input;
    # ID of the model to use.
    string model = "mistral-embed";
|};

public type Response JobOut|LegacyJobMetadataOut;

public type BatchJobOut record {
    @jsondata:Name {value: "succeeded_requests"}
    int succeededRequests;
    record {}? metadata?;
    @jsondata:Name {value: "failed_requests"}
    int failedRequests;
    @jsondata:Name {value: "created_at"}
    int createdAt;
    @jsondata:Name {value: "output_file"}
    string? outputFile?;
    @jsondata:Name {value: "error_file"}
    string? errorFile?;
    @jsondata:Name {value: "input_files"}
    string[] inputFiles;
    @jsondata:Name {value: "completed_at"}
    int? completedAt?;
    string endpoint;
    @jsondata:Name {value: "completed_requests"}
    int completedRequests;
    @jsondata:Name {value: "total_requests"}
    int totalRequests;
    @jsondata:Name {value: "started_at"}
    int? startedAt?;
    string model;
    string id;
    BatchError[] errors;
    "batch" 'object = "batch";
    BatchJobStatus status;
};

public type EmbeddingResponse record {
    *ResponseBase;
    EmbeddingResponseData[] data;
    string id;
    string model;
    string 'object;
    UsageInfo usage;
};

public type ClassificationObject record {
    @jsondata:Name {value: "category_scores"}
    record {||} categoryScores?;
    # Classifier result thresholded
    record {|boolean...;|} categories?;
};

public type CheckpointOut record {
    @jsondata:Name {value: "step_number"}
    int stepNumber;
    @jsondata:Name {value: "created_at"}
    int createdAt;
    MetricOut metrics;
};

# Represents the interface of a memory manager.
public type MemoryManager isolated object {

    # Retrieves memory based on the given memory ID.
    #
    # + memoryId - The ID associated with the memory
    # + return - A `Memory` instance on success, otherwise an `agent:Error`
    public isolated function getMemory(string memoryId) returns Memory|MemoryError;
};

# Represents the memory interface for the agents.
public type Memory isolated object {
    # Retrieves all stored chat messages.
    # + return - An array of messages or an `agent:Error`
    public isolated function get() returns ChatMessage[]|MemoryError;

    # Adds a chat message to the memory.
    # + message - The message to store
    # + return - nil on success, or an `agent:Error` if the operation fails 
    public isolated function update(ChatMessage message) returns MemoryError?;

    # Deletes all stored messages.
    # + return - nil on success, or an `agent:Error` if the operation fails
    public isolated function delete() returns MemoryError?;
};

# Provides an in-memory chat message window with a limit on stored messages.
public isolated class MessageWindowChatMemory {
    *Memory;
    private final int size;
    private ChatSystemMessage? systemPrompt = ();
    private final ChatMessage[] memory = [];

    # Initializes a new memory window with a default or given size.
    # + size - The maximum capacity for stored messages
    public isolated function init(int size = 10) {
        self.size = size;
    }

    # Retrieves a copy of all stored messages, with an optional system prompt.
    # + return - A copy of the messages, or an `agent:Error`
    public isolated function get() returns ChatMessage[]|MemoryError {
        lock {
            ChatMessage[] memory = self.memory.clone();
            ChatSystemMessage? systemPrompt = self.systemPrompt;
            if systemPrompt is ChatSystemMessage {
                memory.unshift(systemPrompt);
            }
            return memory.clone();
        }
    }

    # Adds a message to the window.
    # + message - The `ChatMessage` to store or use as system prompt
    # + return - nil on success, or an `agent:Error` if the operation fails 
    public isolated function update(ChatMessage message) returns MemoryError? {
        lock {
            if message is ChatSystemMessage {
                self.systemPrompt = message.clone();
                return;
            }
            if self.memory.length() >= self.size - 1 {
                _ = self.memory.shift();
            }
            self.memory.push(message.clone());
        }
    }

    # Removes all messages from the memory.
    # + return - nil on success, or an `agent:Error` if the operation fails 
    public isolated function delete() returns MemoryError? {
        lock {
            self.memory.removeAll();
            self.systemPrompt = ();
        }
    }
}

# A default implementation of `agent:MemoryManager`.
public isolated class DefaultMessageWindowChatMemoryManager {
    *MemoryManager;
    private final map<MessageWindowChatMemory> sessions = {};
    private final int size;

    # Initializes a new `agent:DefaultMessageWindowChatMemoryManager`.
    #
    # + size - The maximum number of messages that can be stored in `agent:MessageWindowChatMemory`
    public isolated function init(int size = 10) {
        self.size = size;
    }

    # Retrieves memory based on the given memory ID.
    #
    # + memoryId - The ID associated with the memory
    # + return - A `Memory` instance on success, otherwise an `agent:Error`
    public isolated function getMemory(string memoryId) returns Memory|MemoryError {
        lock {
            if !self.sessions.hasKey(memoryId) {
                self.sessions[memoryId] = new MessageWindowChatMemory(self.size);
            }
            return self.sessions.get(memoryId);
        }
    }
}

import ballerina/test;

@test:Config {}
function testMemoryInitialization() returns error? {
    MessageWindowChatMemory chatMemory = new (size = 5);
    ChatMessage[] history = check chatMemory.get();
    int memoryLength = history.length();
    test:assertEquals(memoryLength, 0);
}

@test:Config {}
function testMemoryUpdateSystemMesage() returns error? {
    MessageWindowChatMemory chatMemory = new (5);
    ChatUserMessage userMessage = {role: "user", content: "Hi im bob"};
    _ = check chatMemory.update(userMessage);
    ChatAssistantMessage assistantMessage = {role: "assistant", content: "Hello Bob! How can I assist you today?"};
    _ = check chatMemory.update(assistantMessage);
    ChatSystemMessage systemMessage = {role: "system", content: "You are an AI assistant to help users get answers. Respond to the human as helpfully and accurately as possible"};
    _ = check chatMemory.update(systemMessage);
    ChatMessage[] history = check chatMemory.get();
    test:assertEquals(history[0], systemMessage);
    test:assertEquals(history.length(), 3);
}

@test:Config {}
function testUpdateExceedMemorySize() returns error? {
    MessageWindowChatMemory chatMemory = new (3);
    ChatUserMessage userMessage = {role: "user", content: "Hi im bob"};
    _ = check chatMemory.update(userMessage);
    ChatAssistantMessage assistantMessage = {role: "assistant", content: "Hello Bob! How can I assist you today?"};
    _ = check chatMemory.update(assistantMessage);
    ChatSystemMessage systemMessage = {role: "system", content: "You are an AI assistant to help users get answers. Respond to the human as helpfully and accurately as possible"};
    _ = check chatMemory.update(systemMessage);
    ChatUserMessage userMessage2 = {role: "user", content: "Add teh numbers [2,3,4,5]"};
    _ = check chatMemory.update(userMessage2);
    ChatMessage[] history = check chatMemory.get();
    test:assertEquals(history[0], systemMessage);
    test:assertEquals(history[1], assistantMessage);
    test:assertEquals(history.length(), 3);
}

@test:Config {}
function testClearMemory() returns error? {
    MessageWindowChatMemory chatMemory = new (4);
    ChatUserMessage userMessage = {role: "user", content: "Hi im bob"};
    _ = check chatMemory.update(userMessage);
    ChatAssistantMessage assistantMessage = {role: "assistant", content: "Hello Bob! How can I assist you today?"};
    _ = check chatMemory.update(assistantMessage);
    ChatSystemMessage systemMessage = {role: "system", content: "You are an AI assistant to help users get answers. Respond to the human as helpfully and accurately as possible"};
    _ = check chatMemory.update(systemMessage);
    _ = check chatMemory.delete();
    test:assertEquals(chatMemory.get(), []);
}

@test:Config {}
function testClearEmptyMemory() returns error? {
    MessageWindowChatMemory chatMemory = new (4);
    _ = check chatMemory.delete();
    test:assertEquals(chatMemory.get(), []);
}

import ballerina/file;
import ballerina/io;
import ballerina/test;
import ballerina/yaml;

@test:Config {}
function testOpenApiSchemaTypes() {
    Schema schema = { // simple schema for integer values
        'type: "integer"
    };
    test:assertTrue(schema is IntegerSchema);

    schema = { // primitive schema for specific type of strings
        'type: "string",
        'format: "date-time",
        pattern: "/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}$/"
    };
    test:assertTrue(schema is StringSchema);

    schema = { // primitive schema with additional parameters
        'type: "string",
        'format: "date-time",
        pattern: "/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}$/",
        "additionalParameter": "dummy-value"
    };
    test:assertTrue(schema is StringSchema);

    schema = { // reference schema
        \$ref: "#/components/schemas/Pet"
    };
    test:assertTrue(schema is Reference);

    schema = { // array schema
        items: {
            'type: "string"
        },
        "additionalParameter": "dummy-value"
    };
    test:assertTrue(schema is ArraySchema);

    schema = { // object schema
        'type: "object",
        properties: {}

    };
    test:assertTrue(schema is ObjectSchema);

    schema = { // object schema without type
        properties: {
            name: {
                'type: "string"
            },
            tag: {
                'type: "string"
            }
        }
    };
    test:assertTrue(schema is ObjectSchema);

    schema = { // object schema without properties
        'type: "object"
    };
    test:assertTrue(schema is ObjectSchema);

    schema = { // unspecified types to string schema
        'enum: ["a", "b", "c"]
    };
    test:assertTrue(schema is StringSchema);

    Schema anyOfSchema = {
        anyOf: [
            schema
        ]
    };
    test:assertTrue(anyOfSchema is AnyOfSchema);

    Schema oneOfSchema = {
        allOf: [
            schema,
            anyOfSchema
        ]
    };
    test:assertTrue(oneOfSchema is AllOfSchema);
}

@test:Config {}
function testOpenApiParser() returns error? {
    string dirPath = "tests/resources/openapi";
    file:MetaData[] openApiDir = check file:readDir(dirPath);
    foreach file:MetaData specInfo in openApiDir {
        map<json> openApiSpec;
        string filePath = specInfo.absPath;
        if filePath.endsWith(".yaml") || filePath.endsWith(".yml") {
            openApiSpec = check yaml:readFile(filePath).ensureType();
        }
        else if filePath.endsWith(".json") {
            openApiSpec = check io:fileReadJson(filePath).ensureType();
        }
        else {
            return error(string `Unsupported file type in the '${dirPath}' directory`);
        }
        OpenApiSpec|UnsupportedOpenApiVersion|OpenApiParsingError parseSpec = parseOpenApiSpec(openApiSpec);

        if filePath.endsWith("openapi (29).json") && parseSpec is UnsupportedOpenApiVersion {
            continue;
        }
        if parseSpec is OpenApiParsingError {
            test:assertFail(string `Failed to parse the OpenAPI at '${filePath}' due to: ${parseSpec.toString()}`);
        }
    }
}

// Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

listener http:Listener sts = new(9445,
    secureSocket = {
        key: {
            certFile: "./resources/sts/public.crt",
            keyFile: "./resources/sts/private.key"
        }
    }
);

isolated service /oauth2 on sts {

    // This JWKs endpoint respond with a JSON object that represents a set of JWKs.
    // https://tools.ietf.org/html/rfc7517#section-5
    isolated resource function get jwks() returns json {
        return {
            "keys": [{
                "kty": "EC",
                "crv": "P-256",
                "x": "MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4",
                "y": "4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM",
                "use": "enc",
                "kid": "1"
            },
            {
                "kty": "RSA",
                "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMstn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbISD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqbw0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw",
                "e": "AQAB",
                "alg": "RS256",
                "kid": "2011-04-29"
            },
            {
                "kty": "RSA",
                "e": "AQAB",
                "use": "sig",
                "kid": "NTAxZmMxNDMyZDg3MTU1ZGM0MzEzODJhZWI4NDNlZDU1OGFkNjFiMQ",
                "alg": "RS256",
                "n": "AIFcoun1YlS4mShJ8OfcczYtZXGIes_XWZ7oPhfYCqhSIJnXD3vqrUu4GXNY2E41jAm8dd7BS5GajR3g1GnaZrSqN0w3bjpdbKjOnM98l2-i9-JP5XoedJsyDzZmml8Xd7zkKCuDqZIDtZ99poevrZKd7Gx5n2Kg0K5FStbZmDbTyX30gi0_griIZyVCXKOzdLp2sfskmTeu_wF_vrCaagIQCGSc60Yurnjd0RQiMWA10jL8axJjnZ-IDgtKNQK_buQafTedrKqhmzdceozSot231I9dth7uXvmPSjpn23IYUIpdj_NXCIt9FSoMg5-Q3lhLg6GK3nZOPuqgGa8TMPs="
            }]
        };
    }
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

enum Status {
    ON,
    OFF
}

type User record {|
    string name;
    int age;
|};

type Person User;

type Data string|int|float|decimal|boolean|byte|Status|User|json|map<json>|table<User>|();

type Mail record {
    string body;
};

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

# Defines the common error type for the module.
public type Error distinct error;

# Any error occurred during parsing OpenAPI specification is classified under this error type.
public type OpenApiParsingError distinct Error;

# Stackoverflow errors due to lenthy OpenAPI specification or cyclic references in the specification.
public type ParsingStackOverflowError distinct OpenApiParsingError;

# Errors occurred due to unsupported path parameter serializations.
public type UnsupportedSerializationError distinct OpenApiParsingError;

# Errors due to unsupported OpenAPI specification version.
public type UnsupportedOpenApiVersion distinct OpenApiParsingError;

# Errors due to invalid or broken references in the OpenAPI specification.
public type InvalidReferenceError distinct OpenApiParsingError;

# Errors due to incomplete OpenAPI specification.
public type IncompleteSpecificationError distinct OpenApiParsingError;

# Errors due to unsupported media type.
public type UnsupportedMediaTypeError distinct OpenApiParsingError;

# Error through due to invalid parameter definition that does not include either schema or content.
public type InvalidParameterDefinition distinct OpenApiParsingError;

# Any error occurred during LLM generation is classified under this error type.
public type LlmError distinct Error;

# Errors occurred due to unexpected responses from the LLM.
public type LlmInvalidResponseError distinct LlmError;

# Errors occurred due to invalid LLM generation.
public type LlmInvalidGenerationError distinct LlmError;

# Errors occurred during LLM generation due to connection.
public type LlmConnectionError distinct LlmError;

# Errors occurred due to termination of the Agent's execution.
public type TaskCompletedError distinct Error;

# Errors occurred due while running HTTP service toolkit.
public type HttpServiceToolKitError distinct Error;

# Any error occurred during parsing HTTP response is classified under this error type.
public type HttpResponseParsingError distinct HttpServiceToolKitError;

# Errors during tool execution.
public type ToolExecutionError distinct Error;

# Error during unexpected output by the tool
public type ToolInvalidOutputError distinct ToolExecutionError;

# Errors occurred due to invalid tool name generated by the LLM.
public type ToolNotFoundError distinct LlmInvalidGenerationError;

# Errors occurred due to invalid input to the tool generated by the LLM.
public type ToolInvalidInputError distinct LlmInvalidGenerationError;

# Errors occurred due to missing mandotary path or query parameters.
public type MissingHttpParameterError distinct ToolInvalidInputError;

# Represents an error that occurs when the maximum number of iterations has been exceeded.
public type MaxIterationExceededError distinct (Error & error<record{|(ExecutionResult|ExecutionError)[] steps;|}>);

# Represents errors that occur during memory-related operations.  
public type MemoryError distinct Error;

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/jballerina.java;

isolated function getToolParameterTypes(FunctionTool functionPointer) returns map<typedesc<anydata>> {
    map<any> typedescriptors = getParameterTypes(functionPointer);
    map<typedesc<anydata>> anydataTypeDesc = {};
    foreach [string, any] [parmeterName, typedescriptor] in typedescriptors.entries() {
        if typedescriptor is typedesc<anydata> {
            anydataTypeDesc[parmeterName] = typedescriptor;
        }
    }
    return anydataTypeDesc;
}

isolated function getParameterTypes(FunctionTool functionPointer) returns map<any> = @java:Method {
    'class: "io.ballerina.lib.ai.Utils"
} external;

isolated function isMapType(typedesc<anydata> typedescVal) returns boolean = @java:Method {
    'class: "io.ballerina.lib.ai.Utils"
} external;

isolated function getFunctionName(FunctionTool toolFunction) returns string = @java:Method {
    'class: "io.ballerina.lib.ai.Utils"
} external;

isolated function getArgsWithDefaultValues(FunctionTool toolFunction, map<anydata> value)
returns map<anydata> = @java:Method {
    'class: "io.ballerina.lib.ai.Utils"
} external;

isolated function invokeOnChatMessageFunction(any event, string eventFunction, service object {} serviceObj) 
    returns ChatRespMessage|error = @java:Method {
        'class: "io.ballerina.lib.ai.NativeHttpToChatServiceAdaptor"
} external;

// Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

type ElectronicItem record {|
    readonly string code;
    string brand;
    string model;
    string price;
    int qty;
|};

type BookItem record {|
    readonly string code;
    string title;
    string authors;
    string price;
    int qty;
|};

table<ElectronicItem> key(code) electronicsTable = table [
    {
        "code": "APMBA132021",
        "brand": "Apple",
        "model": "Mac Book AIR M1 (13-inch 2021)",
        "price": "$1249.00",
        "qty": 32
    },
    {
        "code": "SOWH1000XM4",
        "brand": "Sony",
        "model": "WH-1000XM4",
        "price": "$349.99",
        "qty": 75
    }
];

table<BookItem> key(code) booksTable = table [
    {
        "code": "978-1617295959",
        "title": "Microservices Security in Action",
        "authors": "Prabath Siriwardena and Nuwan Dias",
        "price": "$50.99",
        "qty": 10
    },
    {
        "code": "978-1484220498",
        "title": "Advanced API Security",
        "authors": "Prabath Siriwardena",
        "price": "$15.39",
        "qty": 10
    }
];

public type InventoryItem ElectronicItem|BookItem;

public map<table<InventoryItem>> inventory = {
    electronics: electronicsTable,
    books: booksTable
};

public function increaseQty(string itemCategory, string itemCode, int qty) {
    InventoryItem item = filterInventoryItem(itemCategory, itemCode);
    item.qty += qty;
}

public function decreaseQty(string itemCategory, string itemCode, int qty) {
    InventoryItem item = filterInventoryItem(itemCategory, itemCode);
    item.qty -= qty;
}

function filterInventoryItem(string itemCategory, string itemCode) returns InventoryItem {
    table<InventoryItem> key(code) inventoryTable = <table<InventoryItem> key(code)>inventory[itemCategory];
    return inventoryTable.get(itemCode);
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerinax/ai.agent;
import ballerina/http;

listener http:Listener httpListener = http:getDefaultListener();
listener agent:Listener chatListener = new (httpListener);

service /chatService on chatListener {
    resource function post chat(@http:Payload agent:ChatReqMessage request) returns agent:ChatRespMessage|error {
        return {
            message: request.sessionId + ": " + request.message
        };
    }
}

// Copyright (c) 2019 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/log;

# Represents the error type of the module. This will be returned if an error occurred while issuing/validating a JWT
# or any operation related to JWT auth providers.
public type Error distinct error;

// Logs and prepares the `error` as a `jwt:Error`.
isolated function prepareError(string message, error? err = ()) returns Error {
    log:printDebug(message, 'error = err);
    if err is error {
        return error Error(message, err);
    }
    return error Error(message);
}

// Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

listener http:Listener sts = new(9445,
    secureSocket = {
        key: {
            certFile: "./resources/public.crt",
            keyFile: "./resources/private.key"
        }
    }
);

service /oauth2 on sts {

    // This JWKs endpoint respond with a JSON object that represents a set of JWKs.
    // https://tools.ietf.org/html/rfc7517#section-5
    resource function get jwks() returns json {
        return {
            "keys": [{
                "kty": "EC",
                "crv": "P-256",
                "x": "MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4",
                "y": "4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM",
                "use": "enc",
                "kid": "1"
            },
            {
                "kty": "RSA",
                "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMstn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbISD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqbw0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw",
                "e": "AQAB",
                "alg": "RS256",
                "kid": "2011-04-29"
            },
            {
                "kty": "RSA",
                "e": "AQAB",
                "use": "sig",
                "kid": "NTAxZmMxNDMyZDg3MTU1ZGM0MzEzODJhZWI4NDNlZDU1OGFkNjFiMQ",
                "alg": "RS256",
                "n": "AIFcoun1YlS4mShJ8OfcczYtZXGIes_XWZ7oPhfYCqhSIJnXD3vqrUu4GXNY2E41jAm8dd7BS5GajR3g1GnaZrSqN0w3bjpdbKjOnM98l2-i9-JP5XoedJsyDzZmml8Xd7zkKCuDqZIDtZ99poevrZKd7Gx5n2Kg0K5FStbZmDbTyX30gi0_griIZyVCXKOzdLp2sfskmTeu_wF_vrCaagIQCGSc60Yurnjd0RQiMWA10jL8axJjnZ-IDgtKNQK_buQafTedrKqhmzdceozSot231I9dth7uXvmPSjpn23IYUIpdj_NXCIt9FSoMg5-Q3lhLg6GK3nZOPuqgGa8TMPs="
            }]
        };
    }
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/log;

# Supported input types by the Tool schemas.
public enum InputType {
    STRING = "string",
    INTEGER = "integer",
    FLOAT = "float",
    BOOLEAN = "boolean",
    NUMBER = "number",
    OBJECT = "object",
    ARRAY = "array"
}

# Primitive types supported by the Tool schemas.
public type PrimitiveType int|string|boolean|float|decimal;

# Defines a constant value field in the schema.
public type ConstantValueSchema record {|
    # The constant value.
    json 'const;
|};

# Defines a internal value field in the schema
public type InternalValueSchema record {|
    *ConstantValueSchema;
|};

# Defines a base input type schema.
public type BaseInputSchema record {|
    # Description of the input
    string description?;
    # Default value of the input
    json default?;
    # Indicates whether the value can be null.
    boolean nullable?;
|};

# Defines a base input schema with type field.
public type BaseInputTypeSchema record {|
    *BaseInputSchema;
    # Input data type
    InputType 'type;
|};

# Defines a primitive input field in the schema.
public type PrimitiveInputSchema record {|
    *BaseInputTypeSchema;
    # Input data type. Should be one of `STRING`, `INTEGER`, `NUMBER`, or `BOOLEAN`.
    STRING|INTEGER|NUMBER|BOOLEAN 'type;
    # Format of the input. This is not applicable for `BOOLEAN` type.
    string format?;
    # Pattern of the input. This is only applicable for `STRING` type.
    string pattern?;
    # Enum values of the input. This is only applicable for `STRING` type.
    (PrimitiveType?)[] 'enum?;
    # Default value of the input
    PrimitiveType default?;
|};

# Defines an `anyOf` input field in the schema. Follows OpenAPI 3.x specification.
public type AnyOfInputSchema record {|
    *BaseInputSchema;
    # List of possible input types
    JsonSubSchema[] anyOf;
|};

# Defines an `allOf` input field in the schema. Follows OpenAPI 3.x specification.
public type AllOfInputSchema record {|
    *BaseInputSchema;
    # List of possible input types
    JsonSubSchema[] allOf;
|};

# Defines an `oneOf` input field in the schema. Follows OpenAPI 3.x specification.
public type OneOfInputSchema record {|
    # List of possible input types
    JsonSubSchema[] oneOf;
    # Indicates whether the value can be null.
    boolean nullable?;
    # Description of the input
    string description?;
|};

# Defines a `not` input field in the schema. Follows OpenAPI 3.x specification.
public type NotInputSchema record {|
    *BaseInputSchema;
    # Schema that is not accepted as an input
    JsonSubSchema not;
|};

# Defines an array input field in the schema.
public type ArrayInputSchema record {|
    *BaseInputTypeSchema;
    # Input data type. Should be `ARRAY`.
    ARRAY 'type = ARRAY;
    # Schema of the array items
    JsonSubSchema items;
    # Default value for the array
    json[] default?;
|};

# Defines an object input field in the schema.
public type ObjectInputSchema record {|
    *BaseInputTypeSchema;
    # Input data type. Should be `OBJECT`.
    OBJECT 'type = OBJECT;
    # List of required properties
    string[] required?;
    # Schema of the object properties
    map<JsonSubSchema> properties?;
|};

# Defines a json input schema
public type JsonInputSchema ObjectInputSchema|ArrayInputSchema|AnyOfInputSchema|OneOfInputSchema|AllOfInputSchema|NotInputSchema;

# Defines a json sub schema
public type JsonSubSchema JsonInputSchema|PrimitiveInputSchema|ConstantValueSchema;

// tool definitions ----------------------------
# Defines a tool. This is the only tool type directly understood by the agent. All other tool types are converted to this type using toolkits.
public type ToolConfig record {|
    # Name of the tool
    string name;
    # A description of the tool. This is used by the LLMs to understand the behavior of the tool.
    string description;
    # Input schema expected by the tool. If the tool doesn't expect any input, this should be null.
    JsonInputSchema? parameters = ();
    # Pointer to the function that should be called when the tool is invoked.
    FunctionTool caller;
|};

# Defines the configuration of the Tool annotation.
public type ToolAnnotationConfig record {|
    # The name of the tool. If not provided, defaults to the function pointer name.
    string name?;
    # A description of the tool. This is used by LLMs to understand the tool's behavior.  
    # If not provided, the doc comment used as the description.
    string description?;
    # The input schema expected by the tool. If the tool does not expect any input, this should be null.  
    # If not provided, the input schema is generated automatically. 
    ObjectInputSchema? parameters?;
|};

# Represents the annotation of a function tool.
public annotation ToolAnnotationConfig Tool on function, object function;

# Represents a type alias for an isolated function, representing a function tool.
public type FunctionTool isolated function;

# Generates a array of `ToolConfig` from the given list of function pointers.
# 
# + tools - Array of function pointers annotated with `@agent:Tool` annotation
# + return - Array of `agent:ToolConfig` instances
public isolated function getToolConfigs(FunctionTool[] tools) returns ToolConfig[] {
    ToolConfig[] toolConfigs = [];
    foreach FunctionTool tool in tools {
        ToolConfig|Error toolConfig = getToolConfig(tool);
        if toolConfig is Error {
            log:printWarn("Failed to create 'agent:ToolConfig' for function '" 
                + getFunctionName(tool) + "'. Skipping this tool.", 'error = toolConfig);
        } else {
            toolConfigs.push(toolConfig);
        }
    }
    return toolConfigs;
}

// Copyright (c) 2018 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// NOTE: All the tokens/credentials used in this test are dummy tokens/credentials and used only for testing purposes.

import ballerina/crypto;
import ballerina/io;
import ballerina/lang.'string;
import ballerina/test;

@test:Config {}
isolated function testIssueJwtWithAllFields() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        jwtId: "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
        keyId: "5a0b754-895f-4279-8843-b745e11a57e9",
        customClaims: { "scp": "hello" },
        expTime: 600,
        signatureConfig: {
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    test:assertTrue(result.startsWith("eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QiLCAia2lkIjoiNWEwYjc1NC04OTVmLTQyNzktODg0My1iNzQ1ZTExYTU3ZTkifQ."));
    string header = "{\"alg\":\"RS256\", \"typ\":\"JWT\", \"kid\":\"5a0b754-895f-4279-8843-b745e11a57e9\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"],";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithSingleAud() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: "ballerina",
        expTime: 600,
        signatureConfig: {
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    string header = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":\"ballerina\",";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithSingleAudAndAudAsArray() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina"],
        expTime: 600,
        signatureConfig: {
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    string header = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\"],";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithNoIssOrSub() returns Error? {
    IssuerConfig issuerConfig = {
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    string header = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string payload = "{\"aud\":[\"ballerina\", \"ballerinaSamples\"],";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithNoAudOrSub() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        expTime: 600,
        signatureConfig: {
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    string header = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\",";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithCustomClaims() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        customClaims: { "scope": "test-scope" },
        expTime: 600,
        signatureConfig: {
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    string header = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"],";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithoutSignatureConfig() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600
    };
    string result = check issue(issuerConfig);
    test:assertTrue(result.startsWith("eyJhbGciOiJub25lIiwgInR5cCI6IkpXVCJ9."));
    string header = "{\"alg\":\"none\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithSigningAlgorithmNone() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            algorithm: NONE
        }
    };
    string result = check issue(issuerConfig);
    test:assertTrue(result.startsWith("eyJhbGciOiJub25lIiwgInR5cCI6IkpXVCJ9."));
    string header = "{\"alg\":\"none\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithSigningAlgorithmRS384() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            algorithm: RS384,
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    test:assertTrue(result.startsWith("eyJhbGciOiJSUzM4NCIsICJ0eXAiOiJKV1QifQ."));
    string header = "{\"alg\":\"RS384\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithSigningAlgorithmRS512() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            algorithm: RS512,
            config: {
                keyStore: {
                    path: KEYSTORE_PATH,
                    password: "ballerina"
                },
                keyAlias: "ballerina",
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    test:assertTrue(result.startsWith("eyJhbGciOiJSUzUxMiIsICJ0eXAiOiJKV1QifQ."));
    string header = "{\"alg\":\"RS512\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithSigningAlgorithmHS256() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            algorithm: HS256,
            config: "s3cr3t"
        }
    };
    string result = check issue(issuerConfig);
    test:assertTrue(result.startsWith("eyJhbGciOiJIUzI1NiIsICJ0eXAiOiJKV1QifQ."));
    string header = "{\"alg\":\"HS256\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithSigningAlgorithmHS384() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            algorithm: HS384,
            config: "s3cr3t"
        }
    };
    string result = check issue(issuerConfig);
    test:assertTrue(result.startsWith("eyJhbGciOiJIUzM4NCIsICJ0eXAiOiJKV1QifQ."));
    string header = "{\"alg\":\"HS384\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithSigningAlgorithmHS512() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            algorithm: HS512,
            config: "s3cr3t"
        }
    };
    string result = check issue(issuerConfig);
    test:assertTrue(result.startsWith("eyJhbGciOiJIUzUxMiIsICJ0eXAiOiJKV1QifQ."));
    string header = "{\"alg\":\"HS512\", \"typ\":\"JWT\"}";
    string payload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, header, payload);
}

@test:Config {}
isolated function testIssueJwtWithoutSigningKeyInformation() {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            algorithm: RS256
        }
    };
    string|Error result = issue(issuerConfig);
    if result is Error {
        assertContains(result, "Signing JWT requires keystore information or private key information.");
    } else {
        test:assertFail("Expected error not found.");
    }
}

@test:Config {}
isolated function testIssueJwtWithPrivateKey() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            config: {
                keyFile: PRIVATE_KEY_PATH
            }
        }
    };
    string result = check issue(issuerConfig);
    string expectedHeader = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string expectedPayload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, expectedHeader, expectedPayload);
}

@test:Config {}
isolated function testIssueJwtWithEncryptedPrivateKey() returns Error? {
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            config: {
                keyFile: ENCRYPTED_PRIVATE_KEY_PATH,
                keyPassword: "ballerina"
            }
        }
    };
    string result = check issue(issuerConfig);
    string expectedHeader = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string expectedPayload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, expectedHeader, expectedPayload);
}

@test:Config {}
isolated function testIssueJwtWithCryptoPrivateKey() returns io:Error|crypto:Error|Error? {
    byte[] privateKeyContent = check io:fileReadBytes(PRIVATE_KEY_PATH);
    crypto:PrivateKey privateKey = check crypto:decodeRsaPrivateKeyFromContent(privateKeyContent);
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            config: privateKey
        }
    };
    string result = check issue(issuerConfig);
    string expectedHeader = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string expectedPayload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, expectedHeader, expectedPayload);
}

@test:Config {}
isolated function testIssueJwtWithEncryptedCryptoPrivateKey() returns io:Error|crypto:Error|Error? {
    byte[] privateKeyContent = check io:fileReadBytes(ENCRYPTED_PRIVATE_KEY_PATH);
    crypto:PrivateKey encryptedPrivateKey = check crypto:decodeRsaPrivateKeyFromContent(privateKeyContent, "ballerina");
    IssuerConfig issuerConfig = {
        username: "John",
        issuer: "wso2",
        audience: ["ballerina", "ballerinaSamples"],
        expTime: 600,
        signatureConfig: {
            config: encryptedPrivateKey
        }
    };
    string result = check issue(issuerConfig);
    string expectedHeader = "{\"alg\":\"RS256\", \"typ\":\"JWT\"}";
    string expectedPayload = "{\"iss\":\"wso2\", \"sub\":\"John\", \"aud\":[\"ballerina\", \"ballerinaSamples\"]";
    assertDecodedJwt(result, expectedHeader, expectedPayload);
}

isolated function assertDecodedJwt(string jwt, string header, string payload) {
    string[] parts = re `\.`.split(jwt);
    // check header
    byte[]|Error headerDecodedResult = decodeBase64Url(parts[0]);
    if headerDecodedResult is byte[] {
        string|error resultHeader = 'string:fromBytes(headerDecodedResult);
        if resultHeader is string {
            test:assertEquals(header, resultHeader);
        } else {
            test:assertFail("Assertion failed. Expected string, but found error.");
        }
    } else {
        test:assertFail("Assertion failed. Expected byte[], but found error.");
    }
    // check payload
    byte[]|Error payloadDecodedResult = decodeBase64Url(parts[1]);
    if payloadDecodedResult is byte[] {
        string|error resultPayload = 'string:fromBytes(payloadDecodedResult);
        if resultPayload is string {
            test:assertTrue(resultPayload.startsWith(payload));
        } else {
            test:assertFail("Assertion failed. Expected string, but found error.");
        }
    } else {
        test:assertFail("Assertion failed. Expected byte[], but found error.");
    }
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/io;
import ballerina/test;
import ballerinax/ai.agent;

@test:Config {
    dataProvider: getTools
}
function validateGeneratedSchema(string functionName, agent:FunctionTool tool) returns error? {
    agent:ToolAnnotationConfig generatedConfig = check getToolConfig(tool);
    agent:ToolAnnotationConfig expectedConfig = check getExpectedToolConfig(functionName);
    test:assertEquals(generatedConfig, expectedConfig);
}

function getToolConfig(agent:FunctionTool tool) returns agent:ToolAnnotationConfig|error {
    typedesc<agent:FunctionTool> functionTypedesc = typeof tool;
    return functionTypedesc.@agent:Tool.ensureType();
}

function getExpectedToolConfig(string functionName) returns agent:ToolAnnotationConfig|error {
    json schema = check io:fileReadJson(string `./resources/expected-schemas/${functionName}.json`);
    return schema.cloneWithType();
}

function getTools() returns map<[string, agent:FunctionTool]> => {
    toolWithString: ["toolWithString", toolWithString],
    toolWithInt: ["toolWithInt", toolWithInt],
    toolWithFloat: ["toolWithFloat", toolWithFloat],
    toolWithDecimal: ["toolWithDecimal", toolWithDecimal],
    toolWithByte: ["toolWithByte", toolWithByte],
    toolWithBoolean: ["toolWithBoolean", toolWithBoolean],
    toolWithJson: ["toolWithJson", toolWithJson],
    toolWithJsonMap: ["toolWithJsonMap", toolWithJsonMap],
    toolWithStringArray: ["toolWithStringArray", toolWithStringArray],
    toolWithByteArray: ["toolWithByteArray", toolWithByteArray],
    toolWithRecord: ["toolWithRecord", toolWithRecord],
    toolWithTable: ["toolWithTable", toolWithTable],
    toolWithEnum: ["toolWithEnum", toolWithEnum],
    toolWithDefaultParam: ["toolWithDefaultParam", toolWithDefaultParam],
    toolWithUnion: ["toolWithUnion", toolWithUnion],
    toolWithTypeAlias: ["toolWithTypeAlias", toolWithTypeAlias],
    toolWithIncludedRecord: ["toolWithIncludedRecord", toolWithIncludedRecord],
    toolWithMultipleParams: ["toolWithMultipleParams", toolWithMultipleParams],
    toolWithDocumentation: ["toolWithDocumentation", toolWithDocumentation],
    toolWithOverriddenFunctionName: ["toolWithOverriddenFunctionName", toolWithOverriddenFunctionName],
    toolWithOverriddenDescription: ["toolWithOverriddenDescription", toolWithOverriddenDescription],
    toolWithOverriddenParameterSchema: ["toolWithOverriddenParameterSchema", toolWithOverriddenParameterSchema],
    toolWithOverriddenConfig: ["toolWithOverriddenConfig", toolWithOverriddenConfig]
};

// Copyright (c) 2018 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/cache;
import ballerina/log;
import ballerina/time;

# Represents the listener JWT Auth provider, which is used to authenticate the provided credentials (JWT) against
# the provided JWT validator configurations.
# ```ballerina
# jwt:ListenerJwtAuthProvider provider = new({
#     issuer: "example",
#     audience: "ballerina",
#     signatureConfig: {
#         certificateAlias: "ballerina",
#         trustStore: {
#             path: "/path/to/truststore.p12",
#             password: "ballerina"
#         }
#     }
# });
# ```
public isolated class ListenerJwtAuthProvider {

    private final ValidatorConfig & readonly validatorConfig;
    private final cache:Cache? jwtCache;
    private final cache:Cache? jwksCache;

    # Provides authentication based on the provided JWT.
    #
    # + validatorConfig - JWT validator configurations
    public isolated function init(ValidatorConfig validatorConfig) {
        self.validatorConfig = validatorConfig.cloneReadOnly();
        cache:CacheConfig? jwtCacheConfig = self.validatorConfig?.cacheConfig;
        if jwtCacheConfig is cache:CacheConfig {
            self.jwtCache = new(jwtCacheConfig);
        } else {
            self.jwtCache = ();
        }
        var jwksConfig = self.validatorConfig?.signatureConfig?.jwksConfig;
        if jwksConfig !is () {
            ClientConfiguration clientConfig = jwksConfig.clientConfig;
            cache:CacheConfig? jwksCacheConfig = jwksConfig?.cacheConfig;
            if jwksCacheConfig is cache:CacheConfig {
                self.jwksCache = new(jwksCacheConfig);
                Error? result = preloadJwksToCache(<cache:Cache> (self.jwksCache), jwksConfig.url, clientConfig);
                if result is Error {
                    panic result;
                }
                return;
            }
        }
        self.jwksCache = ();
    }

    # Authenticates the provided JWT.
    #```ballerina
    # boolean result = check provider.authenticate("<credential>");
    # ```
    #
    # + credential - JWT to be authenticated
    # + return - `jwt:Payload` if authentication is successful or else a `jwt:Error` if an error occurred
    public isolated function authenticate(string credential) returns Payload|Error {
        string[] jwtComponents = re `\.`.split(credential);
        if jwtComponents.length() != 3 {
            return prepareError("Credential format does not match to JWT format.");
        }

        cache:Cache? jwtCache = self.jwtCache;
        if jwtCache is cache:Cache && jwtCache.hasKey(credential) {
            Payload? payload = validateFromCache(jwtCache, credential);
            if payload is Payload {
                return payload;
            }
        }

        Payload|Error validationResult = validateJwt(credential, self.validatorConfig, self.jwksCache);
        if validationResult is Payload {
            if jwtCache is cache:Cache {
                addToCache(jwtCache, credential, validationResult);
            }
            return validationResult;
        } else {
            return prepareError("JWT validation failed.", validationResult);
        }
    }
}

isolated function preloadJwksToCache(cache:Cache jwksCache, string url, ClientConfiguration clientConfig) returns Error? {
    string|Error stringResponse = getJwksResponse(url, clientConfig);
    if stringResponse is string {
        json[] jwksArray = check getJwksArray(stringResponse);
        foreach json jwk in jwksArray {
            json|error kid = jwk.kid;
            if kid is string {
                cache:Error? cachedResult = jwksCache.put(kid, jwk);
                if cachedResult is cache:Error {
                    return prepareError("Failed to put JWK for the kid '" + kid + "' to the cache.", cachedResult);
                }
            } else if kid is error {
                return prepareError("Failed to access 'kid' property from the JSON '" + jwk.toString() + "'.", kid);
            } else {
                return prepareError("Failed to extract 'kid' property as a 'string' from the JSON '" + jwk.toString() + "'.");
            }
        }
        return;
    } else {
        return prepareError("Failed to call JWKS endpoint to preload JWKS to the cache.", stringResponse);
    }
}

isolated function validateFromCache(cache:Cache jwtCache, string jwt) returns Payload? {
    any|cache:Error cachedResult = jwtCache.get(jwt);
    if cachedResult is any {
        Payload payload = <Payload> cachedResult;
        int? expTime = payload?.exp;
        // convert to current time and check the expiry time
        [int, decimal] currentTime = time:utcNow();
        if expTime is () || expTime > currentTime[0] {
            return payload;
        }
        cache:Error? result = jwtCache.invalidate(jwt);
        if result is cache:Error {
            log:printDebug("Failed to invalidate JWT from the cache.", 'error = result);
        }
    } else {
        log:printDebug("Failed to retrieve JWT entry from the cache.", 'error = cachedResult);
    }
    return;
}

isolated function addToCache(cache:Cache jwtCache, string jwt, Payload payload) {
    cache:Error? result = jwtCache.put(jwt, payload);
    if result is cache:Error {
        log:printDebug("Failed to add JWT to the cache.", 'error = result);
    }
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;
import ballerina/lang.regexp;
import ballerina/log;

type ToolExecutionResult record {|
    any|error result;
|};

# This is the tool used by LLMs during reasoning.
# This tool is same as the Tool record, but it has a clear separation between the variables that should be generated with the help of the LLMs and the constants that are defined by the users. 
public type AgentTool record {|
    # Name of the tool
    string name;
    # Description of the tool
    string description;
    # Variables that should be generated with the help of the LLMs
    JsonInputSchema variables?;
    # Constants that are defined by the users
    map<json> constants = {};
    # Function that should be called to execute the tool
    isolated function caller;
|};

public isolated class ToolStore {
    public final map<AgentTool> & readonly tools;

    # Register tools to the agent. 
    # These tools will be by the LLM to perform tasks.
    #
    # + tools - A list of tools that are available to the LLM
    # + return - An error if the tool is already registered
    public isolated function init((BaseToolKit|ToolConfig|FunctionTool)... tools) returns Error? {
        if tools.length() == 0 {
            self.tools = {};
            return;
        }
        ToolConfig[] toolList = [];
        foreach BaseToolKit|ToolConfig|FunctionTool tool in tools {
            if tool is FunctionTool {
                ToolConfig toolConfig = check getToolConfig(tool);
                toolList.push(toolConfig);
            } else if tool is BaseToolKit {
                ToolConfig[] toolsFromToolKit = tool.getTools(); // TODO remove this after Ballerina fixes nullpointer exception
                toolList.push(...toolsFromToolKit);
            } else {
                toolList.push(tool);
            }
        }
        map<AgentTool & readonly> toolMap = {};
        check registerTool(toolMap, toolList);
        self.tools = toolMap.cloneReadOnly();
    }

    # execute the tool decided by the LLM.
    #
    # + action - Action object that contains the tool name and inputs
    # + return - ActionResult containing the results of the tool execution or an error if tool execution fails
    isolated function execute(LlmToolResponse action) returns ToolOutput|LlmInvalidGenerationError|ToolExecutionError {
        string name = action.name;
        map<json>? inputs = action.arguments;
        if !self.tools.hasKey(name) {
            return error ToolNotFoundError("Cannot find the tool.", toolName = name,
                instruction = string `Tool "${name}" does not exists.`
                + string ` Use a tool from the list: ${self.tools.keys().toString()}}`);
        }
        map<json>|error inputValues = mergeInputs(inputs, self.tools.get(name).constants);
        if inputValues is error {
            string instruction = string `Tool "${name}"  execution failed due to invalid inputs provided.` +
                string ` Use the schema to provide inputs: ${self.tools.get(name).variables.toString()}`;
            return error ToolInvalidInputError("Tool is provided with invalid inputs.", inputValues, toolName = name,
                inputs = inputs ?: (), instruction = instruction);
        }
        isolated function caller = self.tools.get(name).caller;
        ToolExecutionResult|error execution = trap callFunction(caller, inputValues);
        if execution is error {
            return error ToolExecutionError("Tool execution failed.", execution, toolName = name,
                inputs = inputValues.length() == 0 ? {} : inputValues);
        }
        any|error observation = execution.result;
        if observation is http:Response {
            observation = observation.getStatusCodeRecord();
        }
        if observation is stream<anydata, error?> {
            anydata[]|error result = from anydata item in observation
                select item;
            observation = result;
        }
        if observation is anydata {
            return {value: observation};
        }
        if observation !is error {
            return error ToolInvalidOutputError("Tool returns an invalid output. Expected anydata or error.",
                outputType = typeof observation, toolName = name, inputs = inputValues.length() == 0 ? {} : inputValues);
        }
        if observation.message() == "{ballerina/lang.function}IncompatibleArguments" {
            string instruction = string `Tool "${name}"  execution failed due to invalid inputs provided.`
                + string ` Use the schema to provide inputs: ${self.tools.get(name).variables.toString()}`;
            return error ToolInvalidInputError("Tool is provided with invalid inputs.",
                observation, toolName = name, inputs = inputValues.length() == 0 ? {} : inputValues,
                instruction = instruction);
        }
        return {value: observation};
    }
}

isolated function getToolConfig(FunctionTool tool) returns ToolConfig|Error {
    typedesc<FunctionTool> typedescriptor = typeof tool;
    ToolAnnotationConfig? config = typedescriptor.@Tool;
    if config is () {
        return error Error("The function '" + getFunctionName(tool) + "' must be annotated with `@agent:Tool`.");
    }
    do {
        return {
            name: check config?.name.ensureType(),
            description: check config?.description.ensureType(),
            parameters: check config?.parameters.ensureType(),
            caller: tool
        };
    } on fail error e {
        return error Error("Unable to register the function '" + getFunctionName(tool) + "' as agent tool", e);
    }
}

isolated function callFunction(FunctionTool tool, map<json> llmToolInput) returns ToolExecutionResult {
    anydata[]|error inputArgs = getInputArgumentsOfFunction(tool, llmToolInput);
    if inputArgs is error {
        return {result: inputArgs};
    }
    any|error result = function:call(tool, ...inputArgs);
    return {result};
}

isolated function getInputArgumentsOfFunction(FunctionTool tool, map<json> inputValues) returns anydata[]|error {
    map<anydata> inputArgs = {};
    map<typedesc<anydata>> typedescs = getToolParameterTypes(tool);
    foreach [string, typedesc<anydata>] [parameterName, typedescriptor] in typedescs.entries() {
        if (inputValues.hasKey(parameterName)) {
            anydata inputArg = check inputValues.get(parameterName).cloneWithType(typedescriptor);
            inputArgs[parameterName] = inputArg;
        }
    }
    map<anydata> argsWithDefaultValues = check trap getArgsWithDefaultValues(tool, inputArgs);
    return argsWithDefaultValues.toArray().cloneReadOnly();
}

isolated function registerTool(map<AgentTool & readonly> toolMap, ToolConfig[] tools) returns Error? {
    foreach ToolConfig tool in tools {
        string name = tool.name;
        if name.toLowerAscii().matches(FINAL_ANSWER_REGEX) {
            return error Error(string ` Tool name '${name}' is reserved for the 'Final answer'.`);
        }
        if !name.matches(re `^[a-zA-Z0-9_-]{1,64}$`) {
            log:printWarn(string `Tool name '${name}' contains invalid characters. Only alphanumeric, underscore and hyphen are allowed.`);
            if name.length() > 64 {
                name = name.substring(0, 64);
            }
            name = regexp:replaceAll(re `[^a-zA-Z0-9_-]`, name, "_");
        }
        if toolMap.hasKey(name) {
            return error Error("Duplicated tools. Tool name should be unique.", toolName = name);
        }

        JsonInputSchema|error? variables = tool.parameters.cloneWithType();
        if variables is error {
            return error Error("Unable to regesiter tool", variables);
        }
        map<json> constants = {};

        if variables is JsonInputSchema {
            constants = resolveSchema(variables) ?: {};
        }

        AgentTool agentTool = {
            name,
            description: regexp:replaceAll(re `\n`, tool.description, " "),
            variables,
            constants,
            caller: tool.caller
        };
        toolMap[name] = agentTool.cloneReadOnly();
    }
}

isolated function resolveSchema(JsonInputSchema schema) returns map<json>? {
    // TODO fix when all values are removed as constant, to use null schema
    if schema is ObjectInputSchema {
        map<JsonSubSchema>? properties = schema.properties;
        if properties is () {
            return;
        }
        map<json> values = {};
        foreach [string, JsonSubSchema] [key, subSchema] in properties.entries() {
            json returnedValue = ();
            if subSchema is ArrayInputSchema {
                returnedValue = subSchema?.default;
            }
            else if subSchema is PrimitiveInputSchema {
                returnedValue = subSchema?.default;
            }
            else if subSchema is ConstantValueSchema {
                string tempKey = key; // TODO temporary reference to fix java null pointer issue
                returnedValue = subSchema.'const;
                _ = properties.remove(tempKey);
                string[]? required = schema.required;
                if required !is () {
                    schema.required = from string requiredKey in required
                        where requiredKey != tempKey
                        select requiredKey;
                }
            } else {
                returnedValue = resolveSchema(subSchema);
            }
            if returnedValue !is () {
                values[key] = returnedValue;
            }
        }
        if values.length() > 0 {
            return values;
        }
        return ();
    }
    // skip anyof, oneof, allof, not
    return ();
}

isolated function mergeInputs(map<json>? inputs, map<json> constants) returns map<json> {
    if inputs is () {
        return constants;
    }
    foreach [string, json] [key, value] in constants.entries() {
        if inputs.hasKey(key) {
            json inputValue = inputs[key];
            if inputValue is map<json> && value is map<json> {
                inputs[key] = mergeInputs(inputValue, value);
            }
        } else {
            inputs[key] = value;
        }
    }
    return inputs;
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/lang.regexp;
import ballerinax/ai.agent;

isolated function getNumbers(string prompt) returns string[] {
    regexp:Span[] spans = re `-?\d+\.?\d*`.findAll(prompt);
    return spans.'map(span => span.substring());
}

isolated function getAnswer(string prompt) returns string {
    var result = re `.*(Answer is: .*)\n?`.findGroups(prompt);
    if result is () || result.length() <= 1 {
        return "Sorry! I don't know the answer";
    }
    var answer = result[1];
    return answer is () ? "Sorry! I don't know the answer" : answer.substring();
}

isolated function getDecimals(string[] numbers) returns decimal[] {
    decimal[] decimalVals = [];
    foreach var num in numbers {
        decimal|error decimalVal = decimal:fromString(num);
        decimalVals.push(decimalVal is decimal ? decimalVal : 0d);
    }
    return decimalVals;
}

isolated function getInt(string number) returns int {
    int|error intVal = int:fromString(number);
    return intVal is int ? intVal : 0;
}

type MockLlmToolCall record {|
    string action;
    json action_input;
|};

@agent:Tool
isolated function sum(decimal[] numbers) returns string {
    decimal total = 0;
    foreach decimal number in numbers {
        total += number;
    }
    return string `Answer is: ${total}`;
}

@agent:Tool
isolated function mutiply(int a, int b) returns string {
    return string `Answer is: ${a * b}`;
}

isolated client distinct class MockLlm {
    *agent:Model;

    isolated remote function chat(agent:ChatMessage[] messages, agent:ChatCompletionFunctions[] tools, string? stop)
        returns agent:ChatAssistantMessage|agent:LlmError {
        agent:ChatMessage lastMessage = messages.pop();
        string prompt = lastMessage is agent:ChatUserMessage ? lastMessage.content : "";
        string query = re `Begin!`.split(prompt)[1];
        if (query.includes("Answer is:")) {
            MockLlmToolCall toolCall = {action: "Final answer", action_input: getAnswer(query)};
            return getChatAssistantMessage(string `Answer is:  ${toolCall.toJsonString()})`);
        }
        if (query.toLowerAscii().includes("sum") || query.toLowerAscii().includes("add")) {
            decimal[] numbers = getDecimals(getNumbers(query));
            MockLlmToolCall toolCall = {action: "sum", action_input: {numbers}};
            return getChatAssistantMessage(string `I need to call the sum tool. Action: ${toolCall.toJsonString()}`);
        }
        if (query.toLowerAscii().includes("mult") || query.toLowerAscii().includes("prod")) {
            string[] numbers = getNumbers(query);
            int a = getInt(numbers.shift());
            int b = getInt(numbers.shift());
            MockLlmToolCall toolCall = {action: "mutiply", action_input: {a, b}};
            return getChatAssistantMessage(string `I need to call the sum tool. Action: ${toolCall.toJsonString()}`);
        }
        return error agent:LlmError("I can't understand");
    }
}

isolated function getChatAssistantMessage(string content) returns agent:ChatAssistantMessage {
    return {role: agent:ASSISTANT, content};
}

final MockLlm model = new;
agent:Agent agent = check new (model = model,
    systemPrompt = {role: "Math tutor", instructions: "Help the students with their questions."},
    tools = [sum, mutiply], agentType = agent:REACT_AGENT
);

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/test;

@test:Config
function testAgentToolExecution() returns error? {
    string result = check agent->run("What is the sum of the following numbers 78 90 45 23 8?");
    test:assertEquals(result, "Answer is: 244.0");

    result = check agent->run("What is the product of 78 and 90?");
    test:assertEquals(result, "Answer is: 7020");

    result = check agent->run("Search for 'random'");
    test:assertEquals(result, "Answer is: No result found on doc for 'random'");

    result = check agent->run("List all mails");
    test:assertEquals(result, [{body: "Mail Body 1"}, {body: "Mail Body 2"}, {body: "Mail Body 3"}].toString());
}

import ballerina/test;

ToolConfig searchTool = {
    name: "Search",
    description: " A search engine. Useful for when you need to answer questions about current events",
    parameters: {
        properties: {
            params: {
                properties: {
                    query: {'type: "string", description: "The search query"}
                }
            }
        }
    },
    caller: searchToolMock
};

ToolConfig calculatorTool = {
    name: "Calculator",
    description: "Useful for when you need to answer questions about math.",
    parameters: {
        properties: {
            params: {
                properties: {
                    expression: {'type: "string", description: "The mathematical expression to evaluate"}
                }
            }
        }
    },
    caller: calculatorToolMock
};

OpenAiModel model = test:mock(OpenAiModel, new MockLLM());

@test:Config {
    enable: false
}
function testReActAgentInitialization() {
    ReActAgent|Error agent = new (model, [searchTool, calculatorTool]);
    if agent is Error {
        test:assertFail("Agent creation is unsuccessful");
    }

    ToolInfo toolInfo = {
        toolList: string `${searchTool.name}, ${calculatorTool.name}`,
        "toolIntro": string `Search: ${{"description": searchTool.description, "inputSchema": searchTool.parameters}.toString()}
Calculator: ${{"description": calculatorTool.description, "inputSchema": calculatorTool.parameters}.toString()}`
    };

    test:assertEquals(extractToolInfo(agent.toolStore), toolInfo);
}

@test:Config {
    enable: false
}
function testInitializedPrompt() returns error? {
    ReActAgent agent = check new (model, [searchTool, calculatorTool]);

    string ExpectedPrompt = string `System: Respond to the human as helpfully and accurately as possible. You have access to the following tools:

Search: {"description":" A search engine. Useful for when you need to answer questions about current events","inputSchema":{"type":"object","properties":{"params":{"type":"object","properties":{"query":{"type":"string","description":"The search query"}}}}}}
Calculator: {"description":"Useful for when you need to answer questions about math.","inputSchema":{"type":"object","properties":{"params":{"type":"object","properties":{"expression":{"type":"string","description":"The mathematical expression to evaluate"}}}}}}

Use a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).

Valid "action" values: "Final Answer" or Search, Calculator

Provide only ONE action per $JSON_BLOB, as shown:

${"```"}
{
  "action": $TOOL_NAME,
  "action_input": $INPUT_JSON
}
${"```"}

Follow this format:

Question: input question to answer
Thought: consider previous and subsequent steps
Action:
${"```"}
$JSON_BLOB
${"```"}
Observation: action result
... (repeat Thought/Action/Observation N times)
Thought: I know what to respond
Action:
${"```"}
{
  "action": "Final Answer",
  "action_input": "Final response to human"
}
${"```"}

Begin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if appropriate. Format is Action:${"```"}$JSON_BLOB${"```"}then Observation:.`;

    test:assertEquals(agent.instructionPrompt, ExpectedPrompt);
}

@test:Config {
    enable: false
}
function testAgentExecutorRun() returns error? {
    ReActAgent agent = check new (model, [searchTool, calculatorTool]);
    string query = "Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?";
    Executor agentExecutor = new (agent, DEFAULT_MEMORY_ID, query = query);
    record {|ExecutionResult|LlmChatResponse|ExecutionError|Error value;|}? result = agentExecutor.next();
    if result is () {
        test:assertFail("AgentExecutor.next returns an null during first iteration");
    }
    ExecutionResult|LlmChatResponse|ExecutionError|Error output = result.value;
    if output is Error {
        test:assertFail("AgentExecutor.next returns an error during first iteration");
    }
    test:assertEquals(output?.observation, "Camila Morrone");

    result = agentExecutor.next();
    if result is () {
        test:assertFail("AgentExecutor.next returns an null during second iteration");
    }
    output = result.value;
    if output is Error {
        test:assertFail("AgentExecutor.next returns an error during second iteration");
    }
    test:assertEquals(output?.observation, "25 years");

    result = agentExecutor.next();
    if result is () {
        test:assertFail("AgentExecutor.next returns an null during third iteration");
    }
    output = result.value;
    if output is Error {
        test:assertFail("AgentExecutor.next returns an error during third iteration");
    }
    test:assertEquals(output?.observation, "Answer: 3.991298452658078");
}

@test:Config {
    enable: false
}
function testConstructHistoryPrompt() {
    ExecutionStep[] history = [
        {
            llmResponse: string `Thought: I need to use the "Create wifi" tool to create a new guest wifi account with the given username and password. 
Action:
{
  "tool": "Create wifi",
  "tool_input": {
    "path": "/guest-wifi-accounts",
    "requestBody": {
      "email": "johnny@wso2.com",
      "username": "newGuest",
      "password": "jh123"
    }
  }
}`,
            observation: "Successfully added the wifi account"
        },
        {

            llmResponse: string `Thought: Next, I need to use the "List wifi" tool to get the available list of wifi accounts for the given email.
Action:
{
  "tool": "List wifi",
  "tool_input": {
    "path": "/guest-wifi-accounts/johnny@wso2.com"
  }
}`,
            observation: ["freeWifi.guestOf.johnny", "newGuest.guestOf.johnny"]
        },
        {
            llmResponse: string `Thought: Finally, I need to use the "Send mail" tool to send the list of available wifi accounts to the given email address.
Action:
{
  "tool": "Send mail",
  "tool_input": {
    "recipient": "alica@wso2.com",
    "subject": "Available Wifi Accounts",
    "messageBody": "Here are the available wifi accounts: ['newGuest.guestOf.johnny','newGuest.guestOf.johnny']"
  }
}`,
            observation: error("Error while sending the email(ballerinax/googleapis.gmail)GmailError")
        }
    ];

    string thoughtHistory = constructHistoryPrompt(history);
    test:assertEquals(thoughtHistory, string `Thought: I need to use the "Create wifi" tool to create a new guest wifi account with the given username and password. 
Action:
{
  "tool": "Create wifi",
  "tool_input": {
    "path": "/guest-wifi-accounts",
    "requestBody": {
      "email": "johnny@wso2.com",
      "username": "newGuest",
      "password": "jh123"
    }
  }
}
Observation: Successfully added the wifi account
Thought: Next, I need to use the "List wifi" tool to get the available list of wifi accounts for the given email.
Action:
{
  "tool": "List wifi",
  "tool_input": {
    "path": "/guest-wifi-accounts/johnny@wso2.com"
  }
}
Observation: ["freeWifi.guestOf.johnny","newGuest.guestOf.johnny"]
Thought: Finally, I need to use the "Send mail" tool to send the list of available wifi accounts to the given email address.
Action:
{
  "tool": "Send mail",
  "tool_input": {
    "recipient": "alica@wso2.com",
    "subject": "Available Wifi Accounts",
    "messageBody": "Here are the available wifi accounts: ['newGuest.guestOf.johnny','newGuest.guestOf.johnny']"
  }
}
Observation: Error occured while trying to execute the tool: {"message":"Error while sending the email(ballerinax/googleapis.gmail)GmailError"}
`);

}

@test:Config {}
function testParseLlmReponse() returns error? {
    string llmResponse = string `I know what to respond
Action:
${"```"}
{
  "action": "Final Answer",
  "action_input": "The guest wifi account guestJohn with password abc123 has been successfully created. There are currently no other available wifi accounts."
}
${"```"}`;

    LlmToolResponse|LlmChatResponse parsedResult = check parseReActLlmResponse(llmResponse);
    if parsedResult is LlmToolResponse {
        test:assertFail("Parsed result should be a ChatResponse");
    }
    test:assertEquals(parsedResult.content, "The guest wifi account guestJohn with password abc123 has been successfully created. There are currently no other available wifi accounts.");
}

@test:Config {}
function testParseLlmReponse2() returns error? {
    string llmResponse = string `The pets available for adoption are:
1. Lion 1 (ID: 7)
2. Lion 2 (ID: 8)
3. Lion 3 (ID: 9)
4.  (ID: 11)
5. O~e~kd/!qA4.yfkZJ|)q6c9%kv,/_qL JNObVwE$v48lk4{2hN#V?SCb/{M9ad4N7S4m&$|=!*PG"e#H#${"`"}wwC1;| (ID: -1414197701106907177)
6. 5;x[EY^~6t'.26qSk(7NSPwDTP7oD@TZNQov0=s[?/Kz\6vx^6*'FFHaKp+Gvq-i":bB=;5qG:QK8!!uV/]xYJ&nk~b"lO3!EoQGEY0p-%*|,=c;!oPw7+Rt?EjQrQ;Lu4R:?${"`"}goAU1KPjC*CqkU.{7UNm^(L13wPUpL*Zwa*KST${"`"}>s, (ID: -3408360315760843390)
7. My Pet (ID: 0)
8. Winter (ID: 1122)
9. New name for my pet 1212 (ID: 108333023)
10. doggie (ID: -34)
11. Dog 224 (ID: 224)
12. New name for my pet 1212 (ID: 1016156941)

Action:
${"```"}
{
  "action": "Final Answer",
  "action_input": "The pets available for adoption are: Lion 1 (ID: 7), Lion 2 (ID: 8), Lion 3 (ID: 9),  (ID: 11), O~e~kd/!qA4.yfkZJ|)q6c9%kv,/_qL JNObVwE$v48lk4{2hN#V?SCb/{M9ad4N7S4m&$|=!*PG\"e#H#${"`"}wwC1;| (ID: -1414197701106907177), 5;x[EY^~6t'.26qSk(7NSPwDTP7oD@TZNQov0=s[?/Kz\\6vx^6*'FFHaKp+Gvq-i\":bB=;5qG:QK8!!uV/]xYJ&nk~b\"lO3!EoQGEY0p-%*|,=c;!oPw7+Rt?EjQrQ;Lu4R:?${"`"}goAU1KPjC*CqkU.{7UNm^(L13wPUpL*Zwa*KST${"`"}>s, (ID: -3408360315760843390), My Pet (ID: 0), Winter (ID: 1122), New name for my pet 1212 (ID: 108333023), doggie (ID: -34), Dog 224 (ID: 224), and New name for my pet 1212 (ID: 1016156941)."
}
${"```"}`;

    LlmToolResponse|LlmChatResponse parsedResult = check parseReActLlmResponse(llmResponse);
    if parsedResult is LlmToolResponse {
        test:assertFail("Parsed result should be a ChatResponse");
    }
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
import ballerinax/googleapis.gmail;
import wso2/ai.agent;

configurable string openAIToken = ?;

configurable string wifiAPIUrl = ?;
configurable string wifiTokenUrl = ?;
configurable string wifiClientId = ?;
configurable string wifiClientSecret = ?;
configurable string gmailToken = ?;

const string USER_EMAIL = "johnny@wso2.com";
const string DEFAULT_QUERY = "create a new wifi account with user newGuest and password jh123. " +
"Send the available list of wifi accounts for that email to alica@wso2.com";

// define send mail tool as a function
isolated function sendMail(record {|string senderEmail; gmail:MessageRequest messageRequest;|} input) returns string|error {
    gmail:Client gmail = check new ({auth: {token: gmailToken}});
    gmail:Message message = check gmail->/users/[input.senderEmail]/messages/send.post(input.messageRequest);
    return message.toString();
}

public function main(string query = DEFAULT_QUERY) returns error? {
    agent:Tool sendEmailTool = {
        name: "Send mail",
        description: "useful to send emails to a given recipient",
        parameters: {
            properties: {
                senderEmail: {'const: USER_EMAIL},
                messageRequest: {
                    properties: {
                        to: {
                            items: {'type: agent:STRING}
                        },
                        subject: {'type: agent:STRING},
                        bodyInHtml: {
                            'type: agent:STRING,
                            format: "text/html"
                        }
                    }
                }
            }
        },
        caller: sendMail
    };

    agent:HttpTool[] httpTools = [
        {
            name: "List wifi",
            path: "/guest-wifi-accounts/{ownerEmail}",
            method: agent:GET,
            description: "useful to list the guest wifi accounts.",
            parameters: {
                ownerEmail: {
                    location: agent:PATH,
                    schema: {'type: agent:STRING}
                }
            }
        },
        {
            name: "Create wifi",
            path: "/guest-wifi-accounts",
            method: agent:POST,
            description: "useful to create a guest wifi account.",
            requestBody: {
                schema: {
                    'type: agent:OBJECT,
                    properties: {
                        email: {'type: agent:STRING},
                        username: {'type: agent:STRING},
                        password: {'type: agent:STRING}
                    }
                }
            }
        }
    ];

    // Create the Http toolkit (easily load http tools for a given API) 
    agent:HttpServiceToolKit wifiApiToolKit = check new (wifiAPIUrl, httpTools, {
        auth: {
            tokenUrl: wifiTokenUrl,
            clientId: wifiClientId,
            clientSecret: wifiClientSecret
        }
    });

    agent:ChatGptModel model = check new ({auth: {token: openAIToken}});
    agent:FunctionCallAgent agent = check new (model, wifiApiToolKit, sendEmailTool);

    // Execute the query using agent iterator
    _ = agent:run(agent, query, context = {"userEmail": USER_EMAIL});
}

// Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/cache;
import ballerina/http;
import order_service.representations as rep;

// In memory storage used to store the orders
map<rep:Order> ordersMap = {};

http:Client inventoryClient = check new ("https://localhost:9091",
    secureSocket = {
        cert: "./resources/public.crt",
        key: {
            certFile: "./resources/public.crt",
            keyFile: "./resources/private.key"
        }
    }
);

http:JwtValidatorConfig config = {
    issuer: "wso2",
    audience: "ballerina",
    signatureConfig: {
        jwksConfig: {
            url: "https://localhost:9445/oauth2/jwks",
            clientConfig: {
                secureSocket: {
                    cert: "./resources/public.crt"
                }
            },
            cacheConfig: {
                capacity: 10,
                evictionFactor: 0.25,
                evictionPolicy: cache:LRU,
                defaultMaxAge: -1
            }
        }
    },
    cacheConfig: {
        capacity: 10,
        evictionFactor: 0.25,
        evictionPolicy: cache:LRU,
        defaultMaxAge: -1
    }
};

listener http:Listener orderEP = new (9090, 
    secureSocket = {
        key: {
            certFile: "./resources/public.crt",
            keyFile: "./resources/private.key"
        }
    }
);

service /'order on orderEP {

    @http:ResourceConfig {
        auth: [
            {
                jwtValidatorConfig: config,
                scopes: "add_order"
            }
        ]
    }
    resource function post .(@http:Payload rep:Order 'order) returns rep:OrderCreated|error {
        string orderId = 'order.id;
        ordersMap[orderId] = 'order;
        check updateInventoryQty('order.items, rep:DECREASE);
        return {
            body: {status: "Order '" + orderId + "' created."},
            headers: {"Location": "http://localhost:9090/order/" + orderId}
        };
    }

    @http:ResourceConfig {
        auth: [
            {
                jwtValidatorConfig: config,
                scopes: "update_order"
            }
        ]
    }
    resource function put [string orderId](@http:Payload rep:UpdateOrder updateOrder)
                                            returns rep:OrderUpdated|rep:OrderNotFound|error {
        rep:Order? existingOrder = ordersMap[orderId];
        if existingOrder is rep:Order {
            check updateInventoryQty(existingOrder.items, rep:INCREASE);
            existingOrder.name = updateOrder.name;
            existingOrder.items = updateOrder.items;
            ordersMap[orderId] = existingOrder;
            check updateInventoryQty(existingOrder.items, rep:DECREASE);
            return <rep:OrderUpdated>{
                body: {status: "Order '" + orderId + "' updated."}
            };
        }
        return <rep:OrderNotFound>{
            body: {status: "Order '" + orderId + "' cannot be found."}
        };
    }

    @http:ResourceConfig {
        auth: [
            {
                jwtValidatorConfig: config,
                scopes: "cancel_order"
            }
        ]
    }
    resource function delete [string orderId]() returns rep:OrderCanceled|rep:OrderNotFound|error {
        if ordersMap.hasKey(orderId) {
            rep:Order 'order = ordersMap.remove(orderId);
            check updateInventoryQty('order.items, rep:INCREASE);
            return <rep:OrderCanceled>{
                body: {status: "Order '" + orderId + "' removed."}
            };
        }
        return <rep:OrderNotFound>{
            body: {status: "Order '" + orderId + "' cannot be found."}
        };
    }

    resource function get [string orderId]() returns rep:Order|http:NotFound {
        if ordersMap.hasKey(orderId) {
            return <rep:Order>ordersMap[orderId];
        }
        return {body: {status: "Order '" + orderId + "' cannot be found."}};
    }
}

function updateInventoryQty(rep:OrderItem[] items, rep:InventoryOperation operation) returns error? {
    json|http:ClientError response = inventoryClient->put("/inventory/" + operation, items);
    if response is http:ClientError {
        return error("Failed to " + operation + " the inventory quantity.", response);
    }
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;
import ballerina/lang.regexp;
import ballerina/log;
import ballerina/mime;
import ballerina/url;
import ballerina/xmldata;

type QueryParamEncoding record {
    EncodingStyle style = FORM;
    boolean explode = true;
};

# Serialize the record according to the deepObject style.
#
# + parent - Parent record name
# + anyRecord - Record to be serialized
# + return - Serialized record as a string
isolated function getDeepObjectStyleRequest(string parent, record {} anyRecord) returns string {
    string[] recordArray = [];
    foreach [string, anydata] [key, value] in anyRecord.entries() {
        if value is PrimitiveType {
            recordArray.push(parent + "[" + key + "]" + "=" + getEncodedUri(value.toString()));
        } else if value is PrimitiveType[] {
            recordArray.push(getSerializedArray(parent + "[" + key + "]" + "[]", value, DEEPOBJECT, true));
        } else if value is record {} {
            string nextParent = parent + "[" + key + "]";
            recordArray.push(getDeepObjectStyleRequest(nextParent, value));
        } else if value is record {}[] {
            string nextParent = string `${parent}[${key}]`;
            recordArray.push(getSerializedRecordArray(nextParent, value, DEEPOBJECT));
        }
        recordArray.push("&");
    }
    _ = recordArray.pop();
    return string:'join("", ...recordArray);
}

# Serialize the record according to the form style.
#
# + parent - Parent record name
# + anyRecord - Record to be serialized
# + explode - Specifies whether arrays and objects should generate separate parameters
# + return - Serialized record as a string
isolated function getFormStyleRequest(string parent, record {} anyRecord, boolean explode = true) returns string {
    string[] recordArray = [];
    if explode {
        foreach [string, anydata] [key, value] in anyRecord.entries() {
            if value is PrimitiveType {
                recordArray.push(key, "=", getEncodedUri(value.toString()));
            } else if value is PrimitiveType[] {
                recordArray.push(getSerializedArray(key, value, explode = explode));
            } else if value is record {} {
                recordArray.push(getFormStyleRequest(parent, value, explode));
            }
            recordArray.push("&");
        }
        _ = recordArray.pop();
    } else {
        foreach [string, anydata] [key, value] in anyRecord.entries() {
            if (value is PrimitiveType) {
                recordArray.push(key, ",", getEncodedUri(value.toString()));
            } else if value is PrimitiveType[] {
                recordArray.push(getSerializedArray(key, value, explode = false));
            } else if value is record {} {
                recordArray.push(getFormStyleRequest(parent, value, explode));
            }
            recordArray.push(",");
        }
        _ = recordArray.pop();
    }
    return string:'join("", ...recordArray);
}

# Serialize arrays.
#
# + arrayName - Name of the field with arrays
# + anyArray - Array to be serialized
# + style - Defines how multiple values are delimited
# + explode - Specifies whether arrays and objects should generate separate parameters
# + return - Serialized array as a string
isolated function getSerializedArray(string arrayName, anydata[] anyArray, string style = "form", boolean explode = true) returns string {
    string key = arrayName;
    string[] arrayValues = [];
    if anyArray.length() > 0 {
        if style == FORM && !explode {
            arrayValues.push(key, "=");
            foreach anydata i in anyArray {
                arrayValues.push(getEncodedUri(i.toString()), ",");
            }
        } else if style == SPACEDELIMITED && !explode {
            arrayValues.push(key, "=");
            foreach anydata i in anyArray {
                arrayValues.push(getEncodedUri(i.toString()), "%20");
            }
        } else if style == PIPEDELIMITED && !explode {
            arrayValues.push(key, "=");
            foreach anydata i in anyArray {
                arrayValues.push(getEncodedUri(i.toString()), "|");
            }
        } else if style == DEEPOBJECT {
            foreach anydata i in anyArray {
                arrayValues.push(key, "[]", "=", getEncodedUri(i.toString()), "&");
            }
        } else {
            foreach anydata i in anyArray {
                arrayValues.push(key, "=", getEncodedUri(i.toString()), "&");
            }
        }
        _ = arrayValues.pop();
    }
    return string:'join("", ...arrayValues);
}

# Serialize the array of records according to the form style.
#
# + parent - Parent record name
# + value - Array of records to be serialized
# + style - Defines how multiple values are delimited
# + explode - Specifies whether arrays and objects should generate separate parameters
# + return - Serialized record as a string
isolated function getSerializedRecordArray(string parent, record {}[] value, string style = FORM, boolean explode = true) returns string {
    string[] serializedArray = [];
    if style == DEEPOBJECT {
        int arayIndex = 0;
        foreach var recordItem in value {
            serializedArray.push(getDeepObjectStyleRequest(parent + "[" + arayIndex.toString() + "]", recordItem), "&");
            arayIndex = arayIndex + 1;
        }
    } else {
        if !explode {
            serializedArray.push(parent, "=");
        }
        foreach var recordItem in value {
            serializedArray.push(getFormStyleRequest(parent, recordItem, explode), ",");
        }
    }
    _ = serializedArray.pop();
    return string:'join("", ...serializedArray);
}

# Get Encoded URI for a given value.
#
# + value - Value to be encoded
# + return - Encoded string
isolated function getEncodedUri(anydata value) returns string {
    string|error encoded = url:encode(value.toString(), "UTF8");
    if encoded is string {
        return encoded;
    }
    return value.toString();
}

# Generate query path with query parameter.
#
# + queryParam - Query parameter map
# + encodingMap - Details on serialization mechanism
# + return - Returns generated Path or error at failure of client initialization
isolated function getPathForQueryParam(map<anydata> queryParam, map<QueryParamEncoding> encodingMap = {}) returns string {
    string[] param = [];
    if queryParam.length() > 0 {
        param.push("?");
        foreach var [key, value] in queryParam.entries() {
            if value is () {
                _ = queryParam.remove(key);
                continue;
            }
            QueryParamEncoding encodingData = encodingMap.hasKey(key) ? encodingMap.get(key) : {};
            if value is PrimitiveType {
                param.push(key, "=", getEncodedUri(value.toString()));
            } else if value is PrimitiveType[] {
                param.push(getSerializedArray(key, value, encodingData.style, encodingData.explode));
            } else if value is record {} {
                if encodingData.style == DEEPOBJECT {
                    param.push(getDeepObjectStyleRequest(key, value));
                } else {
                    param.push(getFormStyleRequest(key, value, encodingData.explode));
                }
            } else {
                param.push(key, "=", value.toString());
            }
            param.push("&");
        }
        _ = param.pop();
    }
    string restOfPath = string:'join("", ...param);
    return restOfPath;
}

isolated function getSimpleStyleParams(string key, json parameterValue) returns string|UnsupportedSerializationError {
    if parameterValue is PrimitiveType {
        return parameterValue.toString();
    }
    if parameterValue is PrimitiveType[] {
        string[] arrayValues = from json param in parameterValue
            select param.toString();
        return string:'join(",", ...arrayValues);
    }
    if parameterValue is map<PrimitiveType> {
        string[] arrayValues = [];
        foreach [string, PrimitiveType] [paramKey, paramValue] in parameterValue.entries() {
            arrayValues.push(paramKey, paramValue.toString());
        }
        return string:'join(",", ...arrayValues);
    }
    return error UnsupportedSerializationError(string `Unsupported value for path paremeter serialization.`, pathParam = key, value = parameterValue);
}

isolated function getParamEncodedPath(HttpTool tool, map<json>? parameters) returns string|MissingHttpParameterError|UnsupportedSerializationError {
    // TODO handle special charactors :/?#[]@!$&'()*+,;=
    string pathWithParams = tool.path;
    map<ParameterSchema>? parameterSchemas = tool.parameters;
    if parameters !is () && parameterSchemas !is () {
        map<QueryParamEncoding> queryParamEncoding = {};
        map<json> queryParams = {};
        foreach [string, ParameterSchema] [paramName, paramSchema] in parameterSchemas.entries() {
            if paramSchema.location == PATH {
                if !parameters.hasKey(paramName) {
                    return error MissingHttpParameterError(string `Missing path paremter value in the generated set.`, path = tool.path, pathParam = paramName);
                }
                json parameterValue = parameters.get(paramName);
                string value = check getSimpleStyleParams(paramName, parameterValue);
                pathWithParams = regexp:replaceAll(re `\{${paramName}\}`, pathWithParams, value);
            } else {
                if parameters.hasKey(paramName) {
                    queryParams[paramName] = parameters.get(paramName);
                    queryParamEncoding[paramName] = {
                        style: paramSchema.style ?: FORM,
                        explode: paramSchema.explode ?: true
                    };
                }
            }
        }
        pathWithParams += getPathForQueryParam(queryParams, queryParamEncoding);
    }
    return pathWithParams;
}

isolated function extractResponsePayload(string path, http:Response response) returns HttpOutput|HttpResponseParsingError {
    int code = response.statusCode;
    int|error? contentLength = getContentLength(response);
    if contentLength is error {
        return error HttpResponseParsingError("Error occurred while extracting content length from the response.", contentLength);
    }
    if contentLength == 0 || code == 204 || code == 205 {
        return {
            code,
            path,
            headers: {contentLength}
        };
    }

    json|xml|error body;
    string contentType = response.getContentType();
    match regexp:split(re `;`, contentType)[0].trim() {
        mime:APPLICATION_JSON|mime:APPLICATION_XML|mime:TEXT_PLAIN|mime:TEXT_HTML|mime:TEXT_XML => {
            body = response.getTextPayload();
        }
        "" => {
            body = ();
        }
        _ => {
            body = "<Unsupported Content Type>";
        }
    }
    if body is error {
        return error HttpResponseParsingError("Error occurred while parsing the response payload.", body, contentType = contentType);
    }
    return {
        code,
        path,
        headers: {contentLength: contentLength > 0 ? contentLength : (), contentType},
        body
    };
}

isolated function getContentLength(http:Response response) returns int|error? {
    string|error contentLengthHeader = response.getHeader(mime:CONTENT_LENGTH);
    if contentLengthHeader is error || contentLengthHeader == "" {
        return;
    }
    return int:fromString(contentLengthHeader);
}

isolated function getRequestMessage(string? mediaType, HttpInput httpInput) returns json|xml|error {
    json|xml message;
    if mediaType is string && mediaType.matches(XML_MEDIA) {
        message = check xmldata:fromJson(httpInput?.requestBody);
    } else {
        message = httpInput?.requestBody;
    }
    return message;
}

isolated function getHttpParameters(map<HttpTool> httpTools, string httpMethod, HttpInput httpInput, boolean writeOperation) returns HttpParameters|error {
    HttpTool httpTool = httpTools.get(string `${httpInput.path.toString()}:${httpMethod}`);
    string path = check getParamEncodedPath(httpTool, httpInput?.parameters);
    log:printDebug(string `HTTP ${httpMethod} ${path} ${httpInput?.requestBody.toString()}`);
    if httpInput?.requestBody is () {
        return {path: path, message: ()};
    }
    json|xml message = check getRequestMessage(httpTool.requestBody?.mediaType, httpInput);
    return {path: path, message: message};
}

// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/data.jsondata;
import ballerina/http;
import ballerina/mime;

# Our Chat Completion and Embeddings APIs specification. Create your account on [La Plateforme](https://console.mistral.ai) to get access and read the [docs](https://docs.mistral.ai) to learn how to use it.
public isolated client class Client {
    final http:Client clientEp;

    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://api.mistral.ai/v1") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        http:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }

    # Delete File
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function delete files/[string fileId](map<string|string[]> headers = {}) returns DeleteFileOut|error {
        string resourcePath = string `/files/${getEncodedUri(fileId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Unarchive Fine Tuned Model
    #
    # + modelId - The ID of the model to unarchive.
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function delete fine_tuning/models/[string modelId]/archive(map<string|string[]> headers = {}) returns UnarchiveFTModelOut|error {
        string resourcePath = string `/fine_tuning/models/${getEncodedUri(modelId)}/archive`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Delete Model
    #
    # + modelId - The ID of the model to delete.
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function delete models/[string modelId](map<string|string[]> headers = {}) returns DeleteModelOut|error {
        string resourcePath = string `/models/${getEncodedUri(modelId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get Batch Jobs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get batch/jobs(map<string|string[]> headers = {}, *JobsApiRoutesBatchGetBatchJobsQueries queries) returns BatchJobsOut|error {
        string resourcePath = string `/batch/jobs`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Batch Job
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get batch/jobs/[string jobId](map<string|string[]> headers = {}) returns BatchJobOut|error {
        string resourcePath = string `/batch/jobs/${getEncodedUri(jobId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Files
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get files(map<string|string[]> headers = {}, *FilesApiRoutesListFilesQueries queries) returns ListFilesOut|error {
        string resourcePath = string `/files`;
        map<Encoding> queryParamEncoding = {"sample_type": {style: FORM, explode: true}, "source": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve File
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get files/[string fileId](map<string|string[]> headers = {}) returns RetrieveFileOut|error {
        string resourcePath = string `/files/${getEncodedUri(fileId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Download File
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get files/[string fileId]/content(map<string|string[]> headers = {}) returns byte[]|error {
        string resourcePath = string `/files/${getEncodedUri(fileId)}/content`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Signed Url
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get files/[string fileId]/url(map<string|string[]> headers = {}, *FilesApiRoutesGetSignedUrlQueries queries) returns FileSignedURL|error {
        string resourcePath = string `/files/${getEncodedUri(fileId)}/url`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Fine Tuning Jobs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get fine_tuning/jobs(map<string|string[]> headers = {}, *JobsApiRoutesFineTuningGetFineTuningJobsQueries queries) returns JobsOut|error {
        string resourcePath = string `/fine_tuning/jobs`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Fine Tuning Job
    #
    # + jobId - The ID of the job to analyse.
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get fine_tuning/jobs/[string jobId](map<string|string[]> headers = {}) returns DetailedJobOut|error {
        string resourcePath = string `/fine_tuning/jobs/${getEncodedUri(jobId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Models
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function get models(map<string|string[]> headers = {}) returns ModelList|error {
        string resourcePath = string `/models`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve Model
    #
    # + modelId - The ID of the model to retrieve.
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function get models/[string modelId](map<string|string[]> headers = {}) returns Response\ Retrieve\ Model\ V1\ Models\ \ Model\ Id\ \ Get|error {
        string resourcePath = string `/models/${getEncodedUri(modelId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update Fine Tuned Model
    #
    # + modelId - The ID of the model to update.
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function patch fine_tuning/models/[string modelId](UpdateFTModelIn payload, map<string|string[]> headers = {}) returns FTModelOut|error {
        string resourcePath = string `/fine_tuning/models/${getEncodedUri(modelId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Agents Completion
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function post agents/completions(AgentsCompletionRequest payload, map<string|string[]> headers = {}) returns ChatCompletionResponse|error {
        string resourcePath = string `/agents/completions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create Batch Job
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post batch/jobs(BatchJobIn payload, map<string|string[]> headers = {}) returns BatchJobOut|error {
        string resourcePath = string `/batch/jobs`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Cancel Batch Job
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post batch/jobs/[string jobId]/cancel(map<string|string[]> headers = {}) returns BatchJobOut|error {
        string resourcePath = string `/batch/jobs/${getEncodedUri(jobId)}/cancel`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Chat Completion
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function post chat/completions(ChatCompletionRequest payload, map<string|string[]> headers = {}) returns ChatCompletionResponse|error {
        string resourcePath = string `/chat/completions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Moderations Chat
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function post chat/moderations(ChatModerationRequest payload, map<string|string[]> headers = {}) returns ClassificationResponse|error {
        string resourcePath = string `/chat/moderations`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Embeddings
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function post embeddings(EmbeddingRequest payload, map<string|string[]> headers = {}) returns EmbeddingResponse|error {
        string resourcePath = string `/embeddings`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Upload File
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post files(MultiPartBodyParams payload, map<string|string[]> headers = {}) returns UploadFileOut|error {
        string resourcePath = string `/files`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(payload);
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Fim Completion
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function post fim/completions(FIMCompletionRequest payload, map<string|string[]> headers = {}) returns FIMCompletionResponse|error {
        string resourcePath = string `/fim/completions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create Fine Tuning Job
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function post fine_tuning/jobs(JobIn payload, map<string|string[]> headers = {}, *JobsApiRoutesFineTuningCreateFineTuningJobQueries queries) returns Response|error {
        string resourcePath = string `/fine_tuning/jobs`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    resource isolated function post fine_tuning/jobs/[string jobId]/'start(map<string|string[]> headers = {}) returns DetailedJobOut|error {
        string resourcePath = string `/fine_tuning/jobs/${getEncodedUri(jobId)}/start`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Cancel Fine Tuning Job
    #
    # + jobId - The ID of the job to cancel.
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post fine_tuning/jobs/[string jobId]/cancel(map<string|string[]> headers = {}) returns DetailedJobOut|error {
        string resourcePath = string `/fine_tuning/jobs/${getEncodedUri(jobId)}/cancel`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Archive Fine Tuned Model
    #
    # + modelId - The ID of the model to archive.
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post fine_tuning/models/[string modelId]/archive(map<string|string[]> headers = {}) returns ArchiveFTModelOut|error {
        string resourcePath = string `/fine_tuning/models/${getEncodedUri(modelId)}/archive`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Moderations
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function post moderations(ClassificationRequest payload, map<string|string[]> headers = {}) returns ClassificationResponse|error {
        string resourcePath = string `/moderations`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # OCR
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful Response 
    resource isolated function post ocr(OCRRequest payload, map<string|string[]> headers = {}) returns OCRResponse|error {
        string resourcePath = string `/ocr`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }
}

// Copyright (c) 2024 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/log;

# Function call agent. 
# This agent uses OpenAI function call API to perform the tool selection.
public isolated distinct client class FunctionCallAgent {
    *BaseAgent;
    # Tool store to be used by the agent
    public final ToolStore toolStore;
    # LLM model instance (should be a function call model)
    public final Model model;
    # The memory associated with the agent.
    public final MemoryManager memoryManager;

    # Initialize an Agent.
    #
    # + model - LLM model instance
    # + tools - Tools to be used by the agent
    # + memory - The memory associated with the agent.
    public isolated function init(Model model, (BaseToolKit|ToolConfig|FunctionTool)[] tools,
            MemoryManager memoryManager = new DefaultMessageWindowChatMemoryManager()) returns Error? {
        self.toolStore = check new (...tools);
        self.model = model;
        self.memoryManager = memoryManager;
    }

    # Parse the function calling API response and extract the tool to be executed.
    #
    # + llmResponse - Raw LLM response
    # + return - A record containing the tool decided by the LLM, chat response or an error if the response is invalid
    public isolated function parseLlmResponse(json llmResponse) returns LlmToolResponse|LlmChatResponse|LlmInvalidGenerationError {
        if llmResponse is string {
            return {content: llmResponse};
        }
        if llmResponse !is FunctionCall {
            return error LlmInvalidGenerationError("Invalid response", llmResponse = llmResponse);
        }
        string? name = llmResponse.name;
        if name is () {
            return error LlmInvalidGenerationError("Missing name", name = llmResponse.name, arguments = llmResponse.arguments);
        }
        string? stringArgs = llmResponse.arguments;
        map<json>|error? arguments = ();
        if stringArgs is string {
            arguments = stringArgs.fromJsonStringWithType();
        }
        if arguments is error {
            return error LlmInvalidGenerationError("Invalid arguments", arguments, name = llmResponse.name, arguments = stringArgs);
        }

        return {
            name,
            arguments,
            id: llmResponse.id
        };
    }

    # Use LLM to decide the next tool/step based on the function calling APIs.
    #
    # + progress - Execution progress with the current query and execution history
    # + memoryId - The ID associated with the agent memory
    # + return - LLM response containing the tool or chat response (or an error if the call fails)
    public isolated function selectNextTool(ExecutionProgress progress, string memoryId = DEFAULT_MEMORY_ID) returns json|LlmError {
        ChatMessage[] messages = createFunctionCallMessages(progress);
        Memory|MemoryError memory = self.memoryManager.getMemory(memoryId);
        ChatMessage[]|MemoryError additionalMessages = memory is Memory ? memory.get() : memory;
        if additionalMessages is MemoryError {
            log:printError("Failed to get chat messages from memory", additionalMessages);
        } else {
            messages.unshift(...additionalMessages);
        }

        // TODO: Improve handling of multiple tool calls returned by the LLM.  
        // Currently, tool calls are executed sequentially in separate chat responses.  
        // Update the logic to execute all tool calls together and return a single response.
        ChatAssistantMessage[] response = check self.model->chat(messages,
        from AgentTool tool in self.toolStore.tools.toArray()
        select {
            name: tool.name,
            description: tool.description,
            parameters: tool.variables
        });
        return response[0].content is string ? response[0].content : response[0]?.function_call;
    }

    # Execute the agent for a given user's query.
    #
    # + query - Natural langauge commands to the agent  
    # + maxIter - No. of max iterations that agent will run to execute the task (default: 5)
    # + context - Context values to be used by the agent to execute the task
    # + verbose - If true, then print the reasoning steps (default: true)
    # + memoryId - The ID associated with the agent memory
    # + return - Returns the execution steps tracing the agent's reasoning and outputs from the tools
    isolated remote function run(string query, int maxIter = 5, string|map<json> context = {}, boolean verbose = true,
            string memoryId = DEFAULT_MEMORY_ID)
        returns record {|(ExecutionResult|ExecutionError)[] steps; string answer?;|} {
        return run(self, query, maxIter, context, verbose, memoryId);
    }
}

isolated function createFunctionCallMessages(ExecutionProgress progress) returns ChatMessage[] {
    ChatMessage[] messages = [];
    // include the history
    foreach ExecutionStep step in progress.history {
        FunctionCall|error functionCall = step.llmResponse.fromJsonWithType();
        if functionCall is error {
            panic error Error("Badly formated history for function call agent", llmResponse = step.llmResponse);
        }

        messages.push({
            role: ASSISTANT,
            function_call: functionCall
        },
        {
            role: FUNCTION,
            name: functionCall.name,
            content: getObservationString(step.observation),
            id: functionCall?.id
        });
    }
    return messages;
}

import ballerina/io;
import ballerina/lang.regexp;

type SearchParams record {|
    string query;
|};

type CalculatorParams record {|
    string expression;
|};

type MessageRequest record {|
    string[] to;
    string subject;
    string body;
|};

// create two mock tools 
isolated function searchToolMock(*SearchParams params) returns string {
    string query = params.query.trim().toLowerAscii();
    if regexp:isFullMatch(re `.*girlfriend.*`, query) {
        return "Camila Morrone";

    } else if regexp:isFullMatch(re `.*age.*`, query) {
        return "25 years";
    }
    else {
        return "Can't find. Stop!";
    }
}

isolated function calculatorToolMock(*CalculatorParams params) returns string {
    string expression = params.expression.trim();
    if (expression == "25 ^ 0.43") {
        return "Answer: 3.991298452658078";
    } else {
        return "Can't compute. Some information is missing";
    }
}

isolated function sendMail(record {|string senderEmail; MessageRequest messageRequest;|} 'input) returns string|error {
    if 'input.senderEmail == "test@email.com" {
        return error("Invalid sender email");
    } else {
        return "Mail sent successfully";
    }
}

public client class MockLLM {
    isolated remote function chat(ChatMessage[] messages, ChatCompletionFunctions[] tools, string? stop)
        returns ChatAssistantMessage[]|LlmError {
        ChatMessage lastMessage = messages.pop();
        string prompt = lastMessage is ChatUserMessage ? lastMessage.content : "";
        if prompt.includes("Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?") {
            int queryLevel = regexp:findAll(re `observation`, prompt.toLowerAscii()).length();
            io:println(queryLevel, prompt);
            string content = check getChatAssistantMessageContent(queryLevel);
            return [{role: ASSISTANT, content}];
        }
        return error LlmError("Unexpected prompt to MockLLM");
    }
}

isolated function getChatAssistantMessageContent(int queryLevel) returns string|LlmError {
    match queryLevel {
        3 => {
            return "I should use a search engine to find out who Leo DiCaprio's girlfriend is, and then use a calculator to calculate her current age raised to the 0.43 power." +
                "Action:" +
                "```" +
                "{" +
                    "\"action\": \"Search\"," +
                    "\"action_input\": {" +
                        "\"params\": {" +
                            "\"query\": \"Leo DiCaprio girlfriend\"" +
                        "}" +
                    "}" +
                "}" +
                "```";
        }
        4 => {
            return " I need to find out Camila Morrone's age" +
                "Action:" +
                "```" +
                "{" +
                    "\"action\": \"Search\"," +
                    "\"action_input\": {" +
                        "\"params\": {" +
                            "\"query\": \"Camila Morrone age\"" +
                        "}" +
                    "}" +
                "}" +
                "```";

        }
        5 => {
            {
                return " I now need to calculate the age raised to the 0.43 power" +
                "Action:" +
                "```" +
                "{" +
                    "\"action\": \"Calculator\"," +
                    "\"action_input\": {" +
                        "\"params\": {" +
                            "\"expression\": \"25 ^ 0.43\"" +
                        "}" +
                    "}" +
                "}" +
                "```";
            }
        }
    }
    return error LlmError("Unexpected prompt to MockLLM");
}

isolated function testTool(string a, string b = "default-one", string c = "default-two") returns string {
    return string `${a} ${b} ${c}`;
}

isolated function testToolPanic(string data) returns string {
    error e = error(data);
    panic (e);
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

// Note: DispatcherService class is not used at the moment, can be used in the future.
service class DispatcherService {
    *http:Service;
    private ChatService? chatService = ();

    isolated function addServiceRef(ChatService chatService) {
        self.chatService = chatService;
    }

    isolated function removeServiceRef() {
        self.chatService = ();
    }

    isolated resource function post chatMessage(ChatReqMessage chatRequest) returns ChatRespMessage|error {
        return self.executeRemoteFunc(chatRequest);
    }

    private isolated function executeRemoteFunc(ChatReqMessage chatRequest) returns ChatRespMessage|error {
        ChatService? chatService = self.chatService;
        if chatService is ChatService {
            return invokeOnChatMessageFunction(chatRequest, "onChatMessage", chatService);
        }
        return error("ChatService is not attached");
    }
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerinax/ai.agent;

class Data {
    public int age = 12;
}

@agent:Tool
isolated function toolWithAny(string name, Data data, map<any> anyMap) {

}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerinax/ai.agent;

enum Status {
    ON,
    OFF
}

type User record {|
    string name;
    int age;
|};

# Tool description
# + param - parameter description
@agent:Tool
isolated function toolOne(string|int|float|decimal|boolean|byte|Status|User|json|map<json>|table<User> param) => ();

# Tool description
# + param - parameter description
@agent:Tool {}
isolated function toolTwo(string|int|float|decimal|boolean|byte|Status|User|json|map<json>|table<User> param) => ();

# Tool description
# + param - parameter description
@agent:Tool {

}
isolated function toolThree(string|int|float|decimal|boolean|byte|Status|User|json|map<json>|table<User> param) => ();

# Tool description
# + param - parameter description
@agent:Tool {
    name: "toolFourNewName"
}
isolated function toolFour(string|int|float|decimal|boolean|byte|Status|User|json|map<json>|table<User> param) => ();

# Tool description
# + param - parameter description
@agent:Tool {
    name: "toolFiveNewName",
    parameters: {
        properties: {
            param: {'type: "string"}
        },
        required: ["param"]
    }
}
isolated function toolFive(string|int|float|decimal|boolean|byte|Status|User|json|map<json>|table<User> param) => ();

@agent:Tool
isolated function toolWithAny(string name, any data) => ();

// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/test;

const string KEYSTORE_PATH = "tests/resources/keystore/ballerinaKeystore.p12";
const string TRUSTSTORE_PATH = "tests/resources/keystore/ballerinaTruststore.p12";
const string PRIVATE_KEY_PATH = "tests/resources/key/private.key";
const string ENCRYPTED_PRIVATE_KEY_PATH = "tests/resources/key/encryptedPrivate.key";
const string PUBLIC_CERT_PATH = "tests/resources/cert/public.crt";
const string INVALID_PUBLIC_CERT_PATH = "tests/resources/cert/invalidPublic.crt";

// {
//  "alg": "RS256",
//  "typ": "JWT",
//  "kid": "5a0b754-895f-4279-8843-b745e11a57e9"
// }
// {
//  "iss": "wso2",
//  "sub": "John",
//  "aud": [
//    "ballerina",
//    "ballerinaSamples"
//  ],
//  "jti": "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
//  "exp": 1935400394,
//  "nbf": 1620040394,
//  "iat": 1620040394,
//  "scp": "hello"
// }
const string JWT1 = "eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QiLCAia2lkIjoiNWEwYjc1NC04OTVmLTQyNzktODg0My1iNzQ1ZTExYTU3ZTk" +
                    "ifQ.eyJpc3MiOiJ3c28yIiwgInN1YiI6IkpvaG4iLCAiYXVkIjpbImJhbGxlcmluYSIsICJiYWxsZXJpbmFTYW1wbGVzIl0" +
                    "sICJqdGkiOiJKbGJtTWlPaUpCTVRJNFEwSkRMVWhUTWpVMkluIiwgImV4cCI6MTkzNTQwMDM5NCwgIm5iZiI6MTYyMDA0MD" +
                    "M5NCwgImlhdCI6MTYyMDA0MDM5NCwgInNjcCI6ImhlbGxvIn0.I9XAfgOkIRor-PTshCzikw92N6jNNPmwXsUTr0OI6bMmG" +
                    "oEoHw0Uo1g3zOfgKOFfIN0bVqUs9gcg05biojIqFmMErrfG4h1DIIym4PLXWzQ-JWPNnMFYSAC5C84MvBPU5kYMnNbVSTsp" +
                    "SbQXocY0FHe2_GvhdwHDviRPMS3RnkJxRVORD9BF4DLJuQJdEJUbT_iYSTCd7ay88oCEgm7KGTDKy66-JqC7FAppc7mj7Lk" +
                    "N48T26BW0aC5wN2LJkYql2H3ONewHOTuEFyH6cZl7dfm66hZiryqMK1BIMwecMscUqKof1h8cHWZ4BDeccCJ5vWNe0SHTrx" +
                    "3AWPcXnRd0Vw";

// {
//  "alg": "RS256",
//  "typ": "JWT",
//  "kid": "NTAxZmMxNDMyZDg3MTU1ZGM0MzEzODJhZWI4NDNlZDU1OGFkNjFiMQ"
// }
// {
//  "sub": "admin",
//  "iss": "ballerina",
//  "exp": 1907665746,
//  "jti": "100078234ba23",
//  "aud": [
//    "vEwzbcasJVQm1jVYHUHCjhxZ4tYa"
//  ]
// }
const string JWT2 = "eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QiLCAia2lkIjoiTlRBeFptTXhORE15WkRnM01UVTFaR00wTXpFek9ESmhaV0k" +
                    "0TkRObFpEVTFPR0ZrTmpGaU1RIn0.eyJzdWIiOiJhZG1pbiIsICJpc3MiOiJiYWxsZXJpbmEiLCAiZXhwIjoxOTA3NjY1Nz" +
                    "Q2LCAianRpIjoiMTAwMDc4MjM0YmEyMyIsICJhdWQiOlsidkV3emJjYXNKVlFtMWpWWUhVSENqaHhaNHRZYSJdfQ.E8E7VO" +
                    "18V6MG7Ns87Y314Dqg8RYOMe0WWYlSYFhSv0mHkJQ8bSSyBJzFG0Se_7UsTWFBwzIALw6wUiP7UGraosilf8k6HGJWbTjWt" +
                    "LXfniJXx5NczikzciG8ADddksm-0AMi5uPsgAQdg7FNaH9f4vAL6SPMEYp2gN6GDnWTH7M1vnknwjOwTbQpGrPu_w2V1tbs" +
                    "BwSzof3Fk_cYrntu8D_pfsBu3eqFiJZD7AXUq8EYbgIxpSwvdi6_Rvw2_TAi46drouxXK2Jglz_HvheUVCERT15Y8JNJONJ" +
                    "PJ52MsN6t297hyFV9AmyNPzwHxxmi753TclbapDqDnVPI1tpc-Q";

// {
//  "alg": "RS384",
//  "typ": "JWT"
// }
// {
//  "iss": "wso2",
//  "sub": "John",
//  "aud": "ballerina",
//  "exp": 1935402506,
//  "nbf": 1620042506,
//  "iat": 1620042506
// }
const string JWT3 = "eyJhbGciOiJSUzM4NCIsICJ0eXAiOiJKV1QifQ.eyJpc3MiOiJ3c28yIiwgInN1YiI6IkpvaG4iLCAiYXVkIjoiYmFsbGVy" +
                    "aW5hIiwgImV4cCI6MTkzNTQwMjU4NCwgIm5iZiI6MTYyMDA0MjU4NCwgImlhdCI6MTYyMDA0MjU4NH0.f9HjtIeprPxeYj_" +
                    "_00pUf8TSS_mlNNvzoY8V8Agg27D4YquxVIj5QwbKjSZ7sdLKC_jlVEwyX0fp_YGcSSfoE-s3T_1wY2e36vxzm35CJG8Lcs" +
                    "EHwjtMrilJ-CicHJKsz0QsPSJJTDJe490tmPMukh-z1Urm779gYnJroUzDcgEvnrsiLsJwTl7M_VmS56B-iXk7IFoId_6gX" +
                    "kq3uA9upmyzV6C5C257W_ApMw8icRR8HS19w0NAu5ws_sxkoM6H3SlFqidZgZ0UvTXnvLaQgBaV0RZX8ctzWOqj601vpVqh" +
                    "qGUvTNGFnpd5ZugLKJ1XXs66ZWdfTkYi2NH_-8cK8Q";

// {
//  "alg": "RS512",
//  "typ": "JWT"
// }
// {
//  "iss": "wso2",
//  "sub": "John",
//  "aud": "ballerina",
//  "exp": 1935402506,
//  "nbf": 1620042506,
//  "iat": 1620042506
// }
const string JWT4 = "eyJhbGciOiJSUzUxMiIsICJ0eXAiOiJKV1QifQ.eyJpc3MiOiJ3c28yIiwgInN1YiI6IkpvaG4iLCAiYXVkIjoiYmFsbGVy" +
                    "aW5hIiwgImV4cCI6MTkzNTQwMjUwNiwgIm5iZiI6MTYyMDA0MjUwNiwgImlhdCI6MTYyMDA0MjUwNn0.R6SobPWHg4z8vY4" +
                    "OV8MRNocIbQV3tHrgD9MzJeuifofsCRMLAhjhKtldShxA9BnRegmawV6Hqn0dBHgrEW69ydx-frE3k8-u9LufH82Lb5JKb5" +
                    "ZUm5Zme5PVru628py_e1TGqKyDjMLRwEZUYYxIMV5nmDO6705XDH2sxRSgGBXkJxMGoycnj1UYRLvU7q315js6DKvXY7Yfa" +
                    "VvO0_xTlFs4381lTXRjkK2G1XMjZQQZK7Px4qSBLqvr9uVPHbezlVKwQs4b1jIgwsE4Fx-bjti6tWCV4NhcU4WhoYB8pYkv" +
                    "f4WrBpKhcaZQeAiCUA6bUsqSkewvDwtjL9mUs0OkCw";

// {
//  "alg": "RS256",
//  "typ": "JWT",
//  "kid": "5a0b754-895f-4279-8843-b745e11a57e9"
// }
// {
//  "iss": "wso2",
//  "sub": "John",
//  "aud": [
//    "ballerina",
//    "ballerinaSamples"
//  ],
//  "jti": "JlbmMiOiJBMTI4Q0JDLUhTMjU2In",
//  "exp": 1940845451,
//  "nbf": 1625485451,
//  "iat": 1625485451,
//  "scp": "hello"
// }
const string JWT5 = "eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QiLCAia2lkIjoiNWEwYjc1NC04OTVmLTQyNzktODg0My1iNzQ1ZTExYTU3ZTk" +
                    "ifQ.eyJpc3MiOiJ3c28yIiwgInN1YiI6IkpvaG4iLCAiYXVkIjpbImJhbGxlcmluYSIsICJiYWxsZXJpbmFTYW1wbGVzIl0" +
                    "sICJqdGkiOiJKbGJtTWlPaUpCTVRJNFEwSkRMVWhUTWpVMkluIiwgImV4cCI6MTk0MDg0NTQ1MSwgIm5iZiI6MTYyNTQ4NT" +
                    "Q1MSwgImlhdCI6MTYyNTQ4NTQ1MSwgInNjcCI6ImhlbGxvIn0.G0c9t9AE7BmYhKCNY4DsYmypk4XDQ-lNqpENYUouugWXn" +
                    "t3-d2rpLHxnXNqcIqPBWRV6QuxO-0jcp6LjkjO2khgZ5jMVNFtlyUN4cQ9UEHfwiPAjSlkwT7sAEHPUd8S8wp714eWtkdjo" +
                    "ysgpcdEE3VJi1OgI1SeVDiN6l7jkt-xxhMsbHGYIeTc1lTLgwNtCJaNJKHvi0uJu5x9YfUznett8Dw465DbADhBLMoSBYAT" +
                    "t4flzCBsTGWC7XZaFnwT4mUlX7WpTOgv1Nsq5GVLszvsnzs6BE__Mvr4zl5pdChVbkMXX3US6fYguK268XKjzgtpMVxUpL3" +
                    "CrzwQpIRyI-Q";

// {
//  "alg": "HS256",
//  "typ": "JWT"
// }
// {
//  "iss": "wso2",
//  "sub": "John",
//  "aud": [
//    "ballerina",
//    "ballerinaSamples"
//  ],
//  "exp": 1943255429,
//  "nbf": 1627895429,
//  "iat": 1627895429
// }
const string JWT6 = "eyJhbGciOiJIUzI1NiIsICJ0eXAiOiJKV1QifQ.eyJpc3MiOiJ3c28yIiwgInN1YiI6IkpvaG4iLCAiYXVkIjpbImJhbGxl" +
                    "cmluYSIsICJiYWxsZXJpbmFTYW1wbGVzIl0sICJleHAiOjE5NDMyNTU0MjksICJuYmYiOjE2Mjc4OTU0MjksICJpYXQiOjE" +
                    "2Mjc4OTU0Mjl9.BqFvZtKFj4KiVGkSkbXAcG4mpmSnGM0f60GYMw7dj4k";

// {
//  "alg": "HS384",
//  "typ": "JWT"
// }
// {
//  "iss": "wso2",
//  "sub": "John",
//  "aud": [
//    "ballerina",
//    "ballerinaSamples"
//  ],
//  "exp": 1943257494,
//  "nbf": 1627897494,
//  "iat": 1627897494
// }
const string JWT7 = "eyJhbGciOiJIUzM4NCIsICJ0eXAiOiJKV1QifQ.eyJpc3MiOiJ3c28yIiwgInN1YiI6IkpvaG4iLCAiYXVkIjpbImJhbGxl" +
                    "cmluYSIsICJiYWxsZXJpbmFTYW1wbGVzIl0sICJleHAiOjE5NDMyNTc0OTQsICJuYmYiOjE2Mjc4OTc0OTQsICJpYXQiOjE" +
                    "2Mjc4OTc0OTR9.gwyn7kbaX-AQi0SQQmPoKfazehSsr7XUTnxewKny2qcOOVJrIqlLVyCoyacFlPel";

// {
//  "alg": "HS512",
//  "typ": "JWT"
// }
// {
//  "iss": "wso2",
//  "sub": "John",
//  "aud": [
//    "ballerina",
//    "ballerinaSamples"
//  ],
//  "exp": 1944016504,
//  "nbf": 1628656504,
//  "iat": 1628656504
// }
const string JWT8 = "eyJhbGciOiJIUzUxMiIsICJ0eXAiOiJKV1QifQ.eyJpc3MiOiJ3c28yIiwgInN1YiI6IkpvaG4iLCAiYXVkIjpbImJhbGxl" +
                    "cmluYSIsICJiYWxsZXJpbmFTYW1wbGVzIl0sICJleHAiOjE5NDQwMTY1MDQsICJuYmYiOjE2Mjg2NTY1MDQsICJpYXQiOjE" +
                    "2Mjg2NTY1MDR9.pXPpwlNyqvNdkmDhYYwhKGArcZXbMz9sqXpv-I05Nox65Q0tMDkzSIK-jpkrp-yag737v4GckS8MuZuym" +
                    "ee43Q";

// Builds the complete error message by evaluating all the inner causes and asserts the inclusion.
isolated function assertContains(error err, string text) {
    string message = err.message();
    error? cause = err.cause();
    while cause is error {
        message += " " + cause.message();
        cause = cause.cause();
    }
    test:assertTrue(message.includes(text));
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;

// Configs obtained from: https://github.com/ollama/ollama/blob/main/docs/modelfile.md#parameter
# Represents the model parameters for Ollama text generation.
# These parameters control the behavior and output of the model.
@display {label: "Ollama Model Parameters"}
public type OllamaModelParameters record {|
    # Enable Mirostat sampling for controlling perplexity.  
    # - `0` = disabled  
    # - `1` = Mirostat  
    # - `2` = Mirostat 2.0  
    @display {label: "Mirostat Sampling"}
    0|1|2 mirostat = 0;

    # Influences how quickly the algorithm responds to feedback from the generated text.  
    # A lower value results in slower adjustments, while a higher value makes the model more responsive.  
    @jsondata:Name {value: "mirostat_eta"}
    @display {label: "Mirostat eta"}
    float mirostatEta = 0.1;

    # Controls the balance between coherence and diversity of the output.  
    # A lower value results in more focused and coherent text.  
    @jsondata:Name {value: "mirostat_tau"}
    @display {label: "Mirostat tau"}
    float mirostatTau = 5.0;

    # Sets the size of the context window used to generate the next token.  
    @jsondata:Name {value: "num_ctx"}
    @display {label: "Context Window Size"}
    int numCtx = 2048;

    # Sets how far back the model should look to prevent repetition.  
    # - `0` = disabled  
    # - `-1` = num_ctx  
    @jsondata:Name {value: "repeat_last_n"}
    @display {label: "Repeat Last N"}
    int repeatLastN = 64;

    # Sets how strongly to penalize repetitions.  
    # A higher value (e.g., `1.5`) will penalize repetitions more strongly,  
    # while a lower value (e.g., `0.9`) will be more lenient.  
    @jsondata:Name {value: "repeat_penalty"}
    @display {label: "Repeat Penalty"}
    float repeatPenalty = 1.1;

    # Controls the creativity of the model's responses.  
    # A higher value makes the output more diverse, while a lower value makes it more focused.  
    @display {label: "Temperature"}
    float temperature = 0.8;

    # Sets the random number seed for deterministic text generation.  
    # A specific value ensures the same output for identical prompts.  
    @display {label: "Seed"}
    int seed = 0;

    # Maximum number of tokens to generate.  
    # `-1` allows infinite generation.  
    @jsondata:Name {value: "num_predict"}
    @display {label: "Number of Tokens to Predict"}
    int numPredict = -1;

    # Controls randomness by selecting the top-k most likely next words.  
    # A higher value (e.g., `100`) increases diversity,  
    # while a lower value (e.g., `10`) makes responses more conservative.  
    @jsondata:Name {value: "top_k"}
    @display {label: "Top K"}
    int topK = 40;

    # Controls randomness by considering the cumulative probability of choices.  
    # A higher value (e.g., `0.95`) increases diversity,  
    # while a lower value (e.g., `0.5`) makes responses more conservative.  
    @jsondata:Name {value: "top_p"}
    @display {label: "Top P"}
    float topP = 0.9;

    # Ensures a balance between quality and variety.  
    # Filters out low-probability tokens relative to the highest probability token.  
    @jsondata:Name {value: "min_p"}
    @display {label: "Min P"}
    float minP = 0.0;
|};

type OllamaResponse record {
    string model;
    OllamaMessage message;
};

type OllamaMessage record {
    string role;
    string content;
    OllamaToolCall[] tool_calls?;
};

type OllamaToolCall record {
    OllamaFunction 'function;
};

type OllamaFunction record {
    string name;
    map<json> arguments;
};

const OLLAMA_TOOL_ROLE = "tool";
const OLLAMA_FUNCTION_TYPE = "function";
const OLLAMA_DEFAULT_SERVICE_URL = "http://localhost:11434";

# Represents a client for interacting with an Ollama models.
public isolated client class OllamaModel {
    *Model;
    private final http:Client ollamaClient;
    private final string modelType;
    private final readonly & map<json> modleParameters;

    # Initializes the client with the given connection configuration and model configuration.
    #
    # + modelType - The Ollama model name
    # + serviceUrl - The base URL for the Ollama API endpoint
    # + modleParameters - Additional model parameters
    # + connectionConfig - Additional connection configuration
    # + return - `nil` on success, otherwise an `Error`. 
    public isolated function init(@display {label: "Model Type"} string modelType,
            @display {label: "Service URL"} string serviceUrl = OLLAMA_DEFAULT_SERVICE_URL,
            @display {label: "Ollama Model Parameters"} *OllamaModelParameters modleParameters,
            @display {label: "Connection Configuration"} *ConnectionConfig connectionConfig) returns Error? {
        http:ClientConfiguration clientConfig = {...connectionConfig};
        http:Client|error ollamaClient = new (serviceUrl, clientConfig);
        if ollamaClient is error {
            return error Error("Error while connecting to the model", ollamaClient);
        }
        self.modleParameters = check getModelParameterMap(modleParameters);
        self.ollamaClient = ollamaClient;
        self.modelType = modelType;
    }

    # Sends a chat request to the Ollama model with the given messages and tools.
    #
    # + messages - List of chat messages 
    # + tools - Tool definitions to be used for the tool call
    # + stop - Stop sequence to stop the completion
    # + return - Function to be called, chat response or an error in-case of failures
    isolated remote function chat(ChatMessage[] messages, ChatCompletionFunctions[] tools = [], string? stop = ())
        returns ChatAssistantMessage[]|LlmError {
        // Ollama chat completion API reference: https://github.com/ollama/ollama/blob/main/docs/api.md#generate-a-chat-completion
        json requestPayload = self.prepareRequestPayload(messages, tools, stop);
        OllamaResponse|error response = self.ollamaClient->/api/chat.post(requestPayload);
        if response is error {
            return error LlmConnectionError("Error while connecting to ollama", response);
        }
        return self.mapOllamaResponseToAssistantMessages(response);
    }

    private isolated function prepareRequestPayload(ChatMessage[] messages, ChatCompletionFunctions[] tools, string? stop)
        returns json {
        json[] transformedMessages = messages.'map(isolated function(ChatMessage message) returns json {
            if message is ChatFunctionMessage {
                return {role: OLLAMA_TOOL_ROLE, content: message?.content};
            }
            return message;
        });

        map<json> options = {...self.modleParameters};
        if stop is string {
            options["stop"] = [stop];
        }

        map<json> payload = {
            model: self.modelType,
            messages: transformedMessages,
            'stream: false,
            options
        };
        if tools.length() > 0 {
            payload["tools"] = tools.'map(tool => {'type: OLLAMA_FUNCTION_TYPE, 'function: tool});
        }
        return payload;
    }

    private isolated function mapOllamaResponseToAssistantMessages(OllamaResponse response)
        returns ChatAssistantMessage[] {
        OllamaToolCall[]? toolCalls = response.message?.tool_calls;
        if toolCalls is OllamaToolCall[] {
            return self.mapToolCallsToAssistantMessages(toolCalls);
        }
        return [{role: ASSISTANT, content: response.message.content}];
    }

    private isolated function mapToolCallsToAssistantMessages(OllamaToolCall[] toolCalls)
        returns ChatAssistantMessage[] {
        return from OllamaToolCall toolCall in toolCalls
            select {
                role: ASSISTANT,
                function_call: {
                    name: toolCall.'function.name,
                    arguments: toolCall.'function.arguments.toJsonString()
                }
            };
    }
}

isolated function getModelParameterMap(OllamaModelParameters modleParameters) returns readonly & map<json>|Error {
    do {
        json options = jsondata:toJson(modleParameters);
        map<json> & readonly readonlyOptions = check options.cloneWithType();
        return readonlyOptions;
    } on fail error e {
        return error Error("Error while processing model parameters", e);
    }
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
import wso2/ai.agent;

configurable string openAIToken = ?;
configurable string wifiAPIUrl = ?;
configurable string wifiTokenUrl = ?;
configurable string wifiClientId = ?;
configurable string wifiClientSecret = ?;

const string DEFAULT_QUERY = "create a new guest wifi with user newWifi and password abc123 and show available accounts";

public function main(string query = DEFAULT_QUERY) returns error? {

    // 1) Register the http actions to the Http tookit
    agent:HttpTool listWifiTool = {
        name: "List wifi",
        path: "/guest-wifi-accounts/{ownerEmail}",
        method: agent:GET,
        description: "useful to list the guest wifi accounts.",
        parameters: {
            ownerEmail: {
                location: agent:PATH,
                schema: {
                    'type: "string"
                }
            }
        }
    };

    agent:HttpTool createWifiTool = {
        name: "Create wifi",
        path: "/guest-wifi-accounts",
        method: agent:POST,
        description: "useful to create a guest wifi account.",
        requestBody: {
            schema: {
                properties: {
                    email: {
                        'type: "string"
                    },
                    username: {
                        'type: "string"
                    },
                    password: {
                        'type: "string"
                    }
                }
            }
        }
    };

    agent:HttpServiceToolKit httpToolKit = check new (wifiAPIUrl, [listWifiTool, createWifiTool], {
        auth: {
            tokenUrl: wifiTokenUrl,
            clientId: wifiClientId,
            clientSecret: wifiClientSecret
        }
    });

    // 2) Create the model (brain of the agent)
    agent:ChatGptModel model = check new ({auth: {token: openAIToken}});
    // 3) Create the agent
    agent:FunctionCallAgent agent = check new (model, httpToolKit);
    // 4) Run the agent to execute user's query
    _ = agent:run(agent, query, maxIter = 5, context = "email is john@gmail.com");
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerinax/ai.agent;

type XML xml;

type Record record {|
    XML 'field;
|};

@agent:Tool
isolated function toolWithXml(xml one, XML two, map<XML> three, map<Record> four,
        Record five, table<Record> six, string|Record seven) {
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

# Supported HTTP methods.
public enum HttpMethod {
    GET, POST, DELETE, PUT, PATCH, HEAD, OPTIONS
}

# Defines a HTTP parameter schema (can be query parameter or path parameters).
public type ParameterSchema record {|
    # Whether the parameter is a path or query parameter
    PATH|QUERY location;
    # A brief description of the parameter
    string description?;
    # Whether the parameter is mandatory
    boolean required?;
    # Describes how a specific property value will be serialized depending on its type
    EncodingStyle style?;
    # When this is true, property values of type array or object generate separate parameters for each value of the array, or key-value-pair of the map.
    boolean explode?;
    # Null value is allowed
    boolean nullable?;
    # Whether empty value is allowed
    boolean allowEmptyValue?;
    # Content type of the schema
    string mediaType?;
    # Parameter schema
    JsonSubSchema schema;
|};

# Defines an HTTP tool. This is a special type of tool that can be used to invoke HTTP resources.
public type HttpTool record {|
    # Name of the Http resource tool
    string name;
    # Description of the Http resource tool used by the LLM
    string description;
    # Http method type (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)
    HttpMethod method;
    # Path of the Http resource
    string path;
    # path and query parameters definitions of the Http resource
    map<ParameterSchema> parameters?;
    # Request body definition of the Http resource
    RequestBodySchema requestBody?;
|};

public type RequestBodySchema record {|
    # A brief description of the request body
    string description?;
    # Content type of the request body
    string mediaType?;
    # Request body schema
    JsonSubSchema schema;
|};

type HttpToolJsonSchema record {|
    *ObjectInputSchema;
    record {|
        ConstantValueSchema path;
        ObjectInputSchema parameters?;
        JsonSubSchema requestBody?;
    |} properties;
|};

// input record definitions ----------------------------
# Defines an HTTP input record.
type HttpInput record {|
    # Http tool record
    string path;
    # Path and query parameters for the Http resource
    map<json> parameters?;
    # Request body of the Http resource
    map<json> requestBody?;
|};

# Defines an HTTP parameters record for requests.
type HttpParameters record {|
    # Http path
    string path;
    # Http message
    json|xml message;
|};

# Defines an HTTP output record for requests.
public type HttpOutput record {|
    # HTTP status code of the response
    int code;
    # HTTP path url with encoded paramteres
    string path;
    # Response headers 
    record {|
        # Content type of the response
        string contentType?;
        # Content length of the response
        int contentLength?;
    |} headers;
    # Response payload
    json|xml body?;
|};

# Allows implmenting custom toolkits by extending this type. Toolkits can help to define new types of tools so that agent can understand them.
public type BaseToolKit distinct object {
    # Useful to retrieve the Tools extracted from the Toolkit.
    # + return - An array of Tools
    public isolated function getTools() returns ToolConfig[];
};

# Defines a HTTP tool kit. This is a special type of tool kit that can be used to invoke HTTP resources.
# Require to initialize the toolkit with the service url and http tools that are belongs to a single API. 
public isolated class HttpServiceToolKit {
    *BaseToolKit;
    private final map<HttpTool> & readonly httpTools;
    private final ToolConfig[] & readonly tools;
    private final map<string|string[]> & readonly headers;
    private final http:Client httpClient;

    # Initializes the toolkit with the given service url and http tools.
    #
    # + serviceUrl - The url of the service to be called
    # + httpTools - The http tools to be initialized
    # + clientConfig - The http client configuration associated to the tools
    # + headers - The http headers to be used in the requests
    # + returns - error if the initialization fails
    public isolated function init(string serviceUrl, HttpTool[] httpTools, http:ClientConfiguration clientConfig = {}, map<string|string[]> headers = {}) returns Error? {
        self.headers = headers.cloneReadOnly();
        http:Client|http:Error httpClient = new (serviceUrl, clientConfig);
        if httpClient is http:Error {
            return error Error("Failed to initialize HttpServiceToolKit", httpClient);
        }
        self.httpClient = httpClient;
        self.httpTools = map from HttpTool tool in httpTools
            select [string `${tool.path}:${tool.method}`, tool.cloneReadOnly()];

        ToolConfig[] tools = [];
        foreach HttpTool httpTool in httpTools {
            map<ParameterSchema>? params = httpTool?.parameters;
            RequestBodySchema? requestBody = httpTool?.requestBody;

            ObjectInputSchema? httpParameters = ();
            if params !is () && params.length() > 0 {
                string[] required = [];
                map<JsonSubSchema> properties = {};
                foreach [string, ParameterSchema] [name, 'parameter] in params.entries() {
                    if 'parameter.location == PATH || 'parameter.required == true {
                        required.push(name);
                    }
                    properties[name] = 'parameter.schema;
                }
                httpParameters = {
                    required,
                    properties
                };
            }

            HttpToolJsonSchema parameters = {
                properties: {
                    path: {'const: httpTool.path},
                    parameters: httpParameters,
                    requestBody: requestBody is () ? () : requestBody.schema
                }
            };

            isolated function caller = self.get;
            match httpTool.method {
                GET => { // do nothing (default)
                }
                POST => {
                    caller = self.post;
                }
                DELETE => {
                    caller = self.delete;
                }
                PUT => {
                    caller = self.put;
                }
                PATCH => {
                    caller = self.patch;
                }
                HEAD => {
                    caller = self.head;
                }
                OPTIONS => {
                    caller = self.options;
                }
                _ => {
                    return error Error("invalid http type: " + httpTool.method.toString());
                }
            }
            tools.push({
                name: httpTool.name,
                description: httpTool.description,
                parameters: {
                    properties: {
                        httpInput: parameters
                    },
                    required: ["httpInput"]
                },
                caller
            });
            self.tools = tools.cloneReadOnly();
        }
    }

    # Useful to retrieve the Tools extracted from the HttpTools.
    # + return - An array of Tools corresponding to the HttpTools
    public isolated function getTools() returns ToolConfig[] => self.tools;

    private isolated function get(HttpInput httpInput) returns HttpOutput|Error {
        do {
            HttpParameters httpParameters = check getHttpParameters(self.httpTools, GET, httpInput, false);
            http:Response getResult = check self.httpClient->get(httpParameters.path, headers = self.headers);
            return extractResponsePayload(httpParameters.path, getResult);
        } on fail error e {
            return handleHttpResourceDespatchError(e);
        }
    }

    private isolated function post(HttpInput httpInput) returns HttpOutput|Error {
        do {
            HttpParameters httpParameters = check getHttpParameters(self.httpTools, POST, httpInput, true);
            http:Response postResult = check self.httpClient->post(httpParameters.path, message = httpParameters.message, headers = self.headers);
            return extractResponsePayload(httpParameters.path, postResult);
        } on fail error e {
            return handleHttpResourceDespatchError(e);
        }
    }

    private isolated function delete(HttpInput httpInput) returns HttpOutput|Error {
        do {
            HttpParameters httpParameters = check getHttpParameters(self.httpTools, DELETE, httpInput, true);
            http:Response deleteResult = check self.httpClient->delete(httpParameters.path, message = httpParameters.message, headers = self.headers);
            return extractResponsePayload(httpParameters.path, deleteResult);
        } on fail error e {
            return handleHttpResourceDespatchError(e);
        }
    }

    private isolated function put(HttpInput httpInput) returns HttpOutput|Error {
        do {
            HttpParameters httpParameters = check getHttpParameters(self.httpTools, PUT, httpInput, true);
            http:Response putResult = check self.httpClient->put(httpParameters.path, message = httpParameters.message, headers = self.headers);
            return extractResponsePayload(httpParameters.path, putResult);
        } on fail error e {
            return handleHttpResourceDespatchError(e);
        }
    }

    private isolated function patch(HttpInput httpInput) returns HttpOutput|Error {
        do {
            HttpParameters httpParameters = check getHttpParameters(self.httpTools, PATCH, httpInput, true);
            http:Response patchResult = check self.httpClient->patch(httpParameters.path, message = httpParameters.message, headers = self.headers);
            return extractResponsePayload(httpParameters.path, patchResult);
        } on fail error e {
            return handleHttpResourceDespatchError(e);
        }
    }

    private isolated function head(HttpInput httpInput) returns HttpOutput|Error {
        do {
            HttpParameters httpParameters = check getHttpParameters(self.httpTools, HEAD, httpInput, false);
            http:Response headResult = check self.httpClient->head(httpParameters.path, headers = self.headers);
            return extractResponsePayload(httpParameters.path, headResult);
        } on fail error e {
            return handleHttpResourceDespatchError(e);
        }
    }

    private isolated function options(HttpInput httpInput) returns HttpOutput|Error {
        do {
            HttpParameters httpParameters = check getHttpParameters(self.httpTools, OPTIONS, httpInput, false);
            http:Response optionsResult = check self.httpClient->options(httpParameters.path, headers = self.headers);
            return extractResponsePayload(httpParameters.path, optionsResult);
        } on fail error e {
            return handleHttpResourceDespatchError(e);
        }
    }
}

isolated function handleHttpResourceDespatchError(error e) returns Error {
    if e is Error {
        return e;
    }
    return error Error(e.message(), e);
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

# A server listener for handling chat service requests.
public class Listener {
    private http:Listener httpListener;

    public function init(int|http:Listener listenOn = 8090) returns error? {
        if listenOn is http:Listener {
            self.httpListener = listenOn;
        } else {
            self.httpListener = check new (listenOn);
        }
    }

    public isolated function attach(ChatService chatService, string[]|string? name = ()) returns error? {
        check self.httpListener.attach(chatService, name);
    }

    public isolated function detach(ChatService chatService) returns error? {
        check self.httpListener.detach(chatService);
    }

    public isolated function 'start() returns error? {
        check self.httpListener.start();
    }

    public isolated function gracefulStop() returns error? {
        check self.httpListener.gracefulStop();
    }

    public isolated function immediateStop() returns error? {
        check self.httpListener.immediateStop();
    }
}

// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;
import ballerina/mime;
import ballerina/url;

type SimpleBasicType string|boolean|int|float|decimal;

# Represents encoding mechanism details.
type Encoding record {
    # Defines how multiple values are delimited
    string style = FORM;
    # Specifies whether arrays and objects should generate as separate fields
    boolean explode = true;
    # Specifies the custom content type
    string contentType?;
    # Specifies the custom headers
    map<any> headers?;
};

enum EncodingStyle {
    DEEPOBJECT, FORM, SPACEDELIMITED, PIPEDELIMITED
}

final Encoding & readonly defaultEncoding = {};

# Serialize the record according to the deepObject style.
#
# + parent - Parent record name
# + anyRecord - Record to be serialized
# + return - Serialized record as a string
isolated function getDeepObjectStyleRequest(string parent, record {} anyRecord) returns string {
    string[] recordArray = [];
    foreach [string, anydata] [key, value] in anyRecord.entries() {
        if value is SimpleBasicType {
            recordArray.push(parent + "[" + key + "]" + "=" + getEncodedUri(value.toString()));
        } else if value is SimpleBasicType[] {
            recordArray.push(getSerializedArray(parent + "[" + key + "]" + "[]", value, DEEPOBJECT, true));
        } else if value is record {} {
            string nextParent = parent + "[" + key + "]";
            recordArray.push(getDeepObjectStyleRequest(nextParent, value));
        } else if value is record {}[] {
            string nextParent = parent + "[" + key + "]";
            recordArray.push(getSerializedRecordArray(nextParent, value, DEEPOBJECT));
        }
        recordArray.push("&");
    }
    _ = recordArray.pop();
    return string:'join("", ...recordArray);
}

# Serialize the record according to the form style.
#
# + parent - Parent record name
# + anyRecord - Record to be serialized
# + explode - Specifies whether arrays and objects should generate separate parameters
# + return - Serialized record as a string
isolated function getFormStyleRequest(string parent, record {} anyRecord, boolean explode = true) returns string {
    string[] recordArray = [];
    if explode {
        foreach [string, anydata] [key, value] in anyRecord.entries() {
            if value is SimpleBasicType {
                recordArray.push(key, "=", getEncodedUri(value.toString()));
            } else if value is SimpleBasicType[] {
                recordArray.push(getSerializedArray(key, value, explode = explode));
            } else if value is record {} {
                recordArray.push(getFormStyleRequest(parent, value, explode));
            }
            recordArray.push("&");
        }
        _ = recordArray.pop();
    } else {
        foreach [string, anydata] [key, value] in anyRecord.entries() {
            if value is SimpleBasicType {
                recordArray.push(key, ",", getEncodedUri(value.toString()));
            } else if value is SimpleBasicType[] {
                recordArray.push(getSerializedArray(key, value, explode = false));
            } else if value is record {} {
                recordArray.push(getFormStyleRequest(parent, value, explode));
            }
            recordArray.push(",");
        }
        _ = recordArray.pop();
    }
    return string:'join("", ...recordArray);
}

# Serialize arrays.
#
# + arrayName - Name of the field with arrays
# + anyArray - Array to be serialized
# + style - Defines how multiple values are delimited
# + explode - Specifies whether arrays and objects should generate separate parameters
# + return - Serialized array as a string
isolated function getSerializedArray(string arrayName, anydata[] anyArray, string style = "form", boolean explode = true) returns string {
    string key = arrayName;
    string[] arrayValues = [];
    if anyArray.length() > 0 {
        if style == FORM && !explode {
            arrayValues.push(key, "=");
            foreach anydata i in anyArray {
                arrayValues.push(getEncodedUri(i.toString()), ",");
            }
        } else if style == SPACEDELIMITED && !explode {
            arrayValues.push(key, "=");
            foreach anydata i in anyArray {
                arrayValues.push(getEncodedUri(i.toString()), "%20");
            }
        } else if style == PIPEDELIMITED && !explode {
            arrayValues.push(key, "=");
            foreach anydata i in anyArray {
                arrayValues.push(getEncodedUri(i.toString()), "|");
            }
        } else if style == DEEPOBJECT {
            foreach anydata i in anyArray {
                arrayValues.push(key, "[]", "=", getEncodedUri(i.toString()), "&");
            }
        } else {
            foreach anydata i in anyArray {
                arrayValues.push(key, "=", getEncodedUri(i.toString()), "&");
            }
        }
        _ = arrayValues.pop();
    }
    return string:'join("", ...arrayValues);
}

# Serialize the array of records according to the form style.
#
# + parent - Parent record name
# + value - Array of records to be serialized
# + style - Defines how multiple values are delimited
# + explode - Specifies whether arrays and objects should generate separate parameters
# + return - Serialized record as a string
isolated function getSerializedRecordArray(string parent, record {}[] value, string style = FORM, boolean explode = true) returns string {
    string[] serializedArray = [];
    if style == DEEPOBJECT {
        int arayIndex = 0;
        foreach var recordItem in value {
            serializedArray.push(getDeepObjectStyleRequest(parent + "[" + arayIndex.toString() + "]", recordItem), "&");
            arayIndex = arayIndex + 1;
        }
    } else {
        if !explode {
            serializedArray.push(parent, "=");
        }
        foreach var recordItem in value {
            serializedArray.push(getFormStyleRequest(parent, recordItem, explode), ",");
        }
    }
    _ = serializedArray.pop();
    return string:'join("", ...serializedArray);
}

# Get Encoded URI for a given value.
#
# + value - Value to be encoded
# + return - Encoded string
isolated function getEncodedUri(anydata value) returns string {
    string|error encoded = url:encode(value.toString(), "UTF8");
    if encoded is string {
        return encoded;
    } else {
        return value.toString();
    }
}

# Generate query path with query parameter.
#
# + queryParam - Query parameter map
# + encodingMap - Details on serialization mechanism
# + return - Returns generated Path or error at failure of client initialization
isolated function getPathForQueryParam(map<anydata> queryParam, map<Encoding> encodingMap = {}) returns string|error {
    map<anydata> queriesMap = http:getQueryMap(queryParam);
    string[] param = [];
    if queriesMap.length() > 0 {
        param.push("?");
        foreach var [key, value] in queriesMap.entries() {
            if value is () {
                _ = queriesMap.remove(key);
                continue;
            }
            Encoding encodingData = encodingMap.hasKey(key) ? encodingMap.get(key) : defaultEncoding;
            if value is SimpleBasicType {
                param.push(key, "=", getEncodedUri(value.toString()));
            } else if value is SimpleBasicType[] {
                param.push(getSerializedArray(key, value, encodingData.style, encodingData.explode));
            } else if value is record {} {
                if encodingData.style == DEEPOBJECT {
                    param.push(getDeepObjectStyleRequest(key, value));
                } else {
                    param.push(getFormStyleRequest(key, value, encodingData.explode));
                }
            } else {
                param.push(key, "=", value.toString());
            }
            param.push("&");
        }
        _ = param.pop();
    }
    string restOfPath = string:'join("", ...param);
    return restOfPath;
}

isolated function createBodyParts(record {|anydata...;|} anyRecord, map<Encoding> encodingMap = {})
returns mime:Entity[]|error {
    mime:Entity[] entities = [];
    foreach [string, anydata] [key, value] in anyRecord.entries() {
        Encoding encodingData = encodingMap.hasKey(key) ? encodingMap.get(key) : {};
        string contentDisposition = string `form-data; name=${key};`;
        if value is record {byte[] fileContent; string fileName;} {
            string fileContentDisposition = string `${contentDisposition} filename=${value.fileName}`;
            mime:Entity entity = check constructEntity(fileContentDisposition, encodingData,
                    value.fileContent);
            entities.push(entity);
        } else if value is byte[] {
            mime:Entity entity = check constructEntity(contentDisposition, encodingData, value);
            entities.push(entity);
        } else if value is SimpleBasicType {
            mime:Entity entity = check constructEntity(contentDisposition, encodingData,
                    value.toString());
            entities.push(entity);
        } else if value is SimpleBasicType[] {
            if encodingData.explode {
                foreach SimpleBasicType member in value {
                    mime:Entity entity = check constructEntity(contentDisposition, encodingData,
                            member.toString());
                    entities.push(entity);
                }
            } else {
                string[] valueStrArray = from SimpleBasicType val in value
                    select val.toString();
                mime:Entity entity = check constructEntity(contentDisposition, encodingData,
                        string:'join(",", ...valueStrArray));
                entities.push(entity);
            }
        } else if value is record {} {
            mime:Entity entity = check constructEntity(contentDisposition, encodingData,
                    value.toString());
            entities.push(entity);
        } else if value is record {}[] {
            if encodingData.explode {
                foreach record {} member in value {
                    mime:Entity entity = check constructEntity(contentDisposition, encodingData,
                            member.toString());
                    entities.push(entity);
                }
            } else {
                string[] valueStrArray = from record {} val in value
                    select val.toJsonString();
                mime:Entity entity = check constructEntity(contentDisposition, encodingData,
                        string:'join(",", ...valueStrArray));
                entities.push(entity);
            }
        }
    }
    return entities;
}

isolated function constructEntity(string contentDisposition, Encoding encoding,
        string|byte[]|record {} data) returns mime:Entity|error {
    mime:Entity entity = new mime:Entity();
    entity.setContentDisposition(mime:getContentDispositionObject(contentDisposition));
    if data is byte[] {
        entity.setByteArray(data);
    } else if data is string {
        entity.setText(data);
    } else {
        entity.setJson(data.toJson());
    }
    check populateEncodingInfo(entity, encoding);
    return entity;
}

isolated function populateEncodingInfo(mime:Entity entity, Encoding encoding) returns error? {
    if encoding?.contentType is string {
        check entity.setContentType(encoding?.contentType.toString());
    }
    map<any>? headers = encoding?.headers;
    if headers is map<any> {
        foreach var [headerName, headerValue] in headers.entries() {
            if headerValue is SimpleBasicType {
                entity.setHeader(headerName, headerValue.toString());
            }
        }
    }
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
import ballerina/http;
import wso2/ai.agent;

configurable string openAIToken = ?;
configurable string wifiAPIUrl = ?;
configurable string wifiTokenUrl = ?;
configurable string wifiClientId = ?;
configurable string wifiClientSecret = ?;

public type WifiGetParams record {|
    string email;
|};

public type WifiCreateParams record {|
    *WifiGetParams;
    string username;
    string password;
|};

final http:Client wifiClient = check new (wifiAPIUrl, {
    auth: {
        tokenUrl: wifiTokenUrl,
        clientId: wifiClientId,
        clientSecret: wifiClientSecret
    }
});

public isolated function listGuestWifi(WifiGetParams params) returns json|error {
    return check wifiClient->/guest\-wifi\-accounts/[params.email];
}

public isolated function addGuestWifi(WifiCreateParams params) returns string|error {
    return check wifiClient->/guest\-wifi\-accounts.post(params);
}

const string DEFAULT_QUERY = "create a new guest wifi with user guestJohn and password abc123 and show available accounts";

public function main(string query = DEFAULT_QUERY) returns error? {

    // 1) Create the model (brain of the agent)
    agent:ChatGptModel model = check new ({auth: {token: openAIToken}});

    // 2) Define functions as tools 
    agent:Tool listwifi = {
        name: "List_Wifi",
        description: "useful to list the guest wifi accounts",
        parameters: {
            properties: {
                email: {
                    'type: "string"
                }
            }
        },
        caller: listGuestWifi
    };

    agent:Tool addWifi = {
        name: "Add_Wifi",
        description: "useful to add a new guest wifi account",
        parameters: {
            properties: {
                email: {
                    'type: "string"
                },
                username: {
                    'type: "string"
                },
                password: {
                    'type: "string"
                }
            }
        },
        caller: addGuestWifi
    };

    // 2) Create the agent 
    agent:ReActAgent agent = check new (model, listwifi, addWifi);

    // 3) Run the agent with user's query
    _ = agent:run(agent, query, context = {"email": "alex@wso2.com"});
}

// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/jballerina.java;

isolated function init() {
    setModule();
}

isolated function setModule() = @java:Method {
    'class: "io.ballerina.stdlib.jwt.ModuleUtils"
} external;

import ballerina/test;

HttpTool[] httpTools = [
    {
        name: "httpGet",
        path: "/example-get/{pathParam}",
        method: GET,
        description: "test HTTP GET tool",
        parameters: {
            pathParam: {
                location: PATH,
                schema: {
                    'type: STRING
                }
            }
        }
    },
    {
        name: "httpPostWithSimpleSchema",
        path: "/example-post",
        method: POST,
        description: "test HTTP POST tool with simple schema",
        requestBody: {
            schema: {
                properties: {
                    attribute1: {'type: STRING},
                    attribute2: {'type: INTEGER},
                    attribute3: {'type: "array", items: {'type: STRING}}
                }
            }
        }
    },
    {
        name: "httpDeleteWithComplexSchema",
        path: "/example-delete",
        method: DELETE,
        description: "test HTTP DELETE tool with complex schema",
        requestBody: {
            schema:
                {
                'type: "object",
                properties:
                {
                    model: {'type: "string", default: "davinci"},
                    prompt: {
                        oneOf: [
                            {'type: "string", default: "test"},
                            {'type: "array", items: {'type: "string"}},
                            {'type: "array", items: {'type: "integer"}},
                            {
                                'type: "array",
                                items: {
                                    'type: "array",
                                    items: {'type: "integer"}
                                }
                            }
                        ]
                    },
                    suffix: {'type: "string"}
                }
            }
        }
    },
    {
        name: "testDefaultWithNull",
        path: "/example-delete",
        method: DELETE,
        description: "test HTTP DELETE tool with complex schema",
        requestBody: {
            schema: {
                'type: "object",
                properties:
                {
                    model: {'type: "string"},
                    prompt: {
                        oneOf: [
                            {'type: "string", default: ()},
                            {'type: "array", items: {'type: "string"}},
                            {'type: "array", items: {'type: "integer"}},
                            {
                                'type: "array",
                                items: {
                                    'type: "array",
                                    items: {'type: "integer", default: ()}
                                }
                            }
                        ]
                    },
                    suffix: {'type: "string"}
                }
            }
        }
    }
];

isolated function getMock(HttpInput input) returns string|error {
    return "";
}

@test:Config {}
function testHttpToolKitInitialization() {
    string serviceURL = "http://test-wifi-url.com";
    HttpServiceToolKit|error httpToolKit = new (serviceURL, httpTools, {auth: {token: "<API-TOKEN>"}}, {"timeout": "10000"});
    if httpToolKit is error {
        test:assertFail("HttpToolKit is not initialized due to an error");
    }
    ToolConfig[]|error tools = httpToolKit.getTools();
    if tools is error {
        test:assertFail("Error occurred while getting tools from HttpToolKit");
    }
    test:assertEquals(tools.length(), 4);

    test:assertEquals(tools[0].name, "httpGet");
    test:assertEquals(tools[0].description, "test HTTP GET tool");
    map<json> expectedToolSchema = {
        'type: "object",
        required: ["httpInput"],
        properties: {
            httpInput: {
                properties: {
                    path: {'const: "/example-get/{pathParam}"},
                    parameters: {
                        'type: "object",
                        required: ["pathParam"],
                        properties: {"pathParam": {'type: "string"}}
                    }
                },
                'type: "object"
            }
        }
    };
    test:assertEquals(tools[0].parameters, expectedToolSchema);

    test:assertEquals(tools[1].name, "httpPostWithSimpleSchema");
    test:assertEquals(tools[1].description, "test HTTP POST tool with simple schema");
    expectedToolSchema = {
        'type: "object",
        required: ["httpInput"],
        properties: {
            httpInput: {
                properties: {
                    path: {'const: "/example-post"},
                    requestBody: {
                        'type: "object",
                        properties: {
                            attribute1: {'type: "string"},
                            attribute2: {'type: "integer"},
                            attribute3: {'type: "array", items: {'type: "string"}}
                        }
                    }
                },
                'type: "object"
            }
        }
    };
    test:assertEquals(tools[1].parameters, expectedToolSchema);

    test:assertEquals(tools[2].name, "httpDeleteWithComplexSchema");
    test:assertEquals(tools[2].description, "test HTTP DELETE tool with complex schema");
    expectedToolSchema = {
        'type: "object",
        required: ["httpInput"],
        properties: {
            httpInput: {
                properties: {
                    path: {'const: "/example-delete"},
                    requestBody: {
                        'type: "object",
                        properties: {
                            model: {'type: "string", "default": "davinci"},
                            prompt: {
                                oneOf: [
                                    {'type: "string", "default": "test"},
                                    {'type: "array", items: {'type: "string"}},
                                    {'type: "array", items: {'type: "integer"}},
                                    {'type: "array", items: {'type: "array", items: {'type: "integer"}}}
                                ]
                            },
                            suffix: {'type: "string"}
                        }
                    }
                },
                'type: "object"
            }
        }
    };
    test:assertEquals(tools[2].parameters, expectedToolSchema);

    test:assertEquals(tools[3].name, "testDefaultWithNull");
    test:assertEquals(tools[3].description, "test HTTP DELETE tool with complex schema");
    expectedToolSchema = {
        'type: "object",
        required: ["httpInput"],
        properties: {
            httpInput: {
                properties: {
                    path: {'const: "/example-delete"},
                    requestBody: {
                        'type: "object",
                        properties: {
                            model: {'type: "string"},
                            prompt: {
                                oneOf: [
                                    {'type: "string"},
                                    {'type: "array", items: {'type: "string"}},
                                    {'type: "array", items: {'type: "integer"}},
                                    {'type: "array", items: {'type: "array", items: {'type: "integer"}}}
                                ]
                            },
                            suffix: {'type: "string"}
                        }
                    }
                },
                'type: "object"
            }
        }
    };
    test:assertEquals(tools[3].parameters, expectedToolSchema);
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

# Represents the system prompt given to the agent.
@display {label: "System Prompt"}
public type SystemPrompt record {|

    # The role or responsibility assigned to the agent
    @display {label: "Role"}
    string role;

    # Specific instructions for the agent
    @display {label: "Instructions"}
    string instructions;
|};

# Represents the different types of agents supported by the module.
@display {label: "Agent Type"}
public enum AgentType {
    # Represents a ReAct agent
    REACT_AGENT,
    # Represents a function call agent
    FUNCTION_CALL_AGENT
}

# Provides a set of configurations for the agent.
@display {label: "Agent Configuration"}
public type AgentConfiguration record {|

    # The system prompt assigned to the agent
    @display {label: "System Prompt"}
    SystemPrompt systemPrompt;

    # The model used by the agent
    @display {label: "Model"}
    Model model;

    # The tools available for the agent
    @display {label: "Tools"}
    (BaseToolKit|ToolConfig|FunctionTool)[] tools = [];

    # Type of the agent
    @display {label: "Agent Type"}
    AgentType agentType = FUNCTION_CALL_AGENT;

    # The maximum number of iterations the agent performs to complete the task
    @display {label: "Maximum Iterations"}
    int maxIter = 5;

    # Specifies whether verbose logging is enabled
    @display {label: "Verbose"}
    boolean verbose = false;

    # The memory manager used by the agent to store and manage conversation history
    @display {label: "Memory Manager"}
    MemoryManager memoryManager = new DefaultMessageWindowChatMemoryManager();
|};

# Represents an agent.
public isolated distinct client class Agent {
    private final BaseAgent agent;
    private final int maxIter;
    private final readonly & SystemPrompt systemPrompt;
    private final boolean verbose;

    # Initialize an Agent.
    #
    # + config - Configuration used to initialize an agent
    public isolated function init(@display {label: "Agent Configuration"} *AgentConfiguration config) returns Error? {
        self.maxIter = config.maxIter;
        self.verbose = config.verbose;
        self.systemPrompt = config.systemPrompt.cloneReadOnly();
        self.agent = config.agentType is REACT_AGENT ? check new ReActAgent(config.model, config.tools, config.memoryManager)
            : check new FunctionCallAgent(config.model, config.tools, config.memoryManager);
    }

    # Executes the agent for a given user query.
    #
    # + query - The natural language input provided to the agent
    # + memoryId - The ID associated with the agent memory
    # + return - The agent's response or an error
    isolated remote function run(@display {label: "Query"} string query, @display {label: "Memory ID"} string memoryId = DEFAULT_MEMORY_ID) returns string|Error {
        var result = self.agent->run(query, self.maxIter, getFomatedSystemPrompt(self.systemPrompt), self.verbose, memoryId);
        string? answer = result.answer;
        if answer is string {
            return answer;
        }
        return constructError(result.steps, self.maxIter);
    }
}

isolated function constructError((ExecutionResult|ExecutionError)[] steps, int maxIter) returns Error {
    if (steps.length() == maxIter) {
        return error MaxIterationExceededError("Maximum iteration limit exceeded while processing the query.",
            steps = steps);
    }
    // Validates whether the execution steps contain only one memory error.
    // If there is exactly one memory error, it is returned; otherwise, null is returned.
    if steps.length() == 1 {
        ExecutionResult|ExecutionError step = steps.pop();
        if step is ExecutionError && step.'error is MemoryError {
            return <MemoryError>step.'error;
        }
    }
    return error Error("Unable to obtain valid answer from the agent", steps = steps);
}

isolated function getFomatedSystemPrompt(SystemPrompt systemPrompt) returns string {
    return string `# Role  
${systemPrompt.role}  

# Instructions  
${systemPrompt.instructions}`;
}

// Copyright (c) 2018 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/jballerina.java;

# Represents the cryptographic algorithms used to secure the JWS.
public type SigningAlgorithm RS256|RS384|RS512|HS256|HS384|HS512|NONE;

# The `RSA-SHA256` algorithm.
public const RS256 = "RS256";

# The `RSA-SHA384` algorithm.
public const RS384 = "RS384";

# The `RSA-SHA512` algorithm.
public const RS512 = "RS512";

# The `HMAC-SHA256` algorithm.
public const HS256 = "HS256";

# The `HMAC-SHA384` algorithm.
public const HS384 = "HS384";

# The `HMAC-SHA512` algorithm.
public const HS512 = "HS512";

# Unsecured JWS (no signing).
public const NONE = "none";

//JOSH header parameters
const string ALG = "alg";
const string TYP = "typ";
const string CTY = "cty";
const string KID = "kid";

//Payload parameters
const string ISS = "iss";
const string SUB = "sub";
const string AUD = "aud";
const string JTI = "jti";
const string EXP = "exp";
const string NBF = "nbf";
const string IAT = "iat";

# Represents JWT header.
#
# + alg - Cryptographic algorithm used to secure the JWS
# + typ - Media type of the JWT
# + cty - Content type, convey structural information about the JWT
# + kid - Key ID, hint indicating which key was used to secure the JWS
public type Header record {
    SigningAlgorithm alg?;
    string typ?;
    string cty?;
    string kid?;
};

# Represents JWT payload.
#
# + iss - Issuer, identifies the principal that issued the JWT
# + sub - Subject, identifies the principal that is the subject of the JWT
# + aud - Audience, identifies the recipients that the JWT is intended for
# + jti - JWT ID, unique identifier for the JWT
# + exp - Expiration time, identifies the expiration time (seconds since the Epoch) on or after which the JWT must not be accepted
# + nbf - Not before, identifies the time (seconds since the Epoch) before which the JWT must not be accepted
# + iat - Issued at, identifies the time (seconds since the Epoch) at which the JWT was issued
public type Payload record {
    string iss?;
    string sub?;
    string|string[] aud?;
    int exp?;
    int nbf?;
    int iat?;
    string jti?;
};

isolated function encodeBase64Url(byte[] input) returns string = @java:Method {
    'class: "io.ballerina.stdlib.jwt.JwtUtils"
} external;

isolated function decodeBase64Url(string input) returns byte[]|Error = @java:Method {
    'class: "io.ballerina.stdlib.jwt.JwtUtils"
} external;

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// model default parameters 
const GPT3_5_MODEL_NAME = "gpt-3.5-turbo";
const OBSERVATION_KEY = "Observation";
const DEFAULT_MAX_TOKEN_COUNT = 512;
const DEFAULT_TEMPERATURE = 0.7d;

// openapi
const OPENAPI_COMPONENTS_KEY = "components";
const OPENAPI_PATTERN_DATE = "yyyy-MM-dd";
const OPENAPI_PATTERN_DATE_TIME = "yyyy-MM-dd'T'HH:mm:ssZ";

// openai
const OPENAI_SERVICE_URL = "https://api.openai.com/v1";

// Anthropic
const ANTHROPIC_SERVICE_URL = "https://api.anthropic.com/v1";

// Mistral AI
const MISTRAL_AI_SERVICE_URL = "https://api.mistral.ai/v1";

//agent
const THOUGHT_KEY = "Thought:";
const BACKTICKS = "```";
const DEFAULT_MEMORY_ID = "memoryId";

final string:RegExp FINAL_ANSWER_REGEX = re `^final.?answer`;

const ACTION_KEY = "action";
const ACTION_NAME_KEY = "name";
const ACTION_ARGUEMENTS_KEY = "arguments";
final string:RegExp ACTION_INPUT_REGEX = re `^action.?input`;
const XML_NAMESPACE = "@xmlns";
const XML_CONTENT = "#content";
final string:RegExp XML_MEDIA = re `application/.*xml`;

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/io;
import ballerina/log;

# Execution progress record
public type ExecutionProgress record {|
    # Question to the agent
    string query;
    # Execution history up to the current action
    ExecutionStep[] history = [];
    # Contextual instruction that can be used by the agent during the execution
    map<json>|string? context = ();
|};

# Execution step information
public type ExecutionStep record {|
    # Response generated by the LLM
    json llmResponse;
    # Observations produced by the tool during the execution
    anydata|error observation;
|};

# Execution step information
public type ExecutionResult record {|
    # Tool decided by the LLM during the reasoning
    LlmToolResponse tool;
    # Observations produced by the tool during the execution
    anydata|error observation;
|};

public type ExecutionError record {|
    # Response generated by the LLM
    json llmResponse;
    # Error caused during the execution
    LlmInvalidGenerationError|ToolExecutionError|MemoryError 'error;
    # Observation on the caused error as additional instruction to the LLM
    string observation;
|};

# An chat response by the LLM
public type LlmChatResponse record {|
    # A text response to the question
    string content;
|};

# Tool selected by LLM to be performed by the agent
public type LlmToolResponse record {|
    # Name of the tool to selected
    string name;
    # Input to the tool
    map<json>? arguments = {};
    # Identifier for the tool call
    string id?;
|};

# Output from executing an action
public type ToolOutput record {|
    # Output value the tool
    anydata|error value;
|};

public type BaseAgent distinct isolated client object {
    public Model model;
    public ToolStore toolStore;
    public MemoryManager memoryManager;

    # Parse the llm response and extract the tool to be executed.
    #
    # + llmResponse - Raw LLM response
    # + return - A record containing the tool decided by the LLM, chat response or an error if the response is invalid
    public isolated function parseLlmResponse(json llmResponse) returns LlmToolResponse|LlmChatResponse|LlmInvalidGenerationError;

    # Use LLM to decide the next tool/step.
    #
    # + progress - Execution progress with the current query and execution history
    # + memoryId - The ID associated with the agent memory
    # + return - LLM response containing the tool or chat response (or an error if the call fails)
    public isolated function selectNextTool(ExecutionProgress progress, string memoryId = DEFAULT_MEMORY_ID) returns json|LlmError;

    isolated remote function run(string query, int maxIter = 5, string|map<json> context = {}, boolean verbose = true, string memoryId = DEFAULT_MEMORY_ID) returns record {|(ExecutionResult|ExecutionError)[] steps; string answer?;|};
};

# An iterator to iterate over agent's execution
public class Iterator {
    *object:Iterable;
    private final Executor executor;

    # Initialize the iterator with the agent and the query.
    #
    # + agent - Agent instance to be executed
    # + memoryId - The ID associated with the agent memory
    # + query - Natural language query to be executed by the agent
    # + context - Contextual information to be used by the agent during the execution
    public isolated function init(BaseAgent agent, string memoryId, *ExecutionProgress progress) {
        self.executor = new (agent, memoryId, progress);
    }

    # Iterate over the agent's execution steps.
    # + return - a record with the execution step or an error if the agent failed
    public function iterator() returns object {
        public function next() returns record {|ExecutionResult|LlmChatResponse|ExecutionError|Error value;|}?;
    } {
        return self.executor;
    }
}

# An executor to perform step-by-step execution of the agent.
public class Executor {
    private boolean isCompleted = false;
    private final string memoryId;
    private final BaseAgent agent;
    # Contains the current execution progress for the agent and the query
    public ExecutionProgress progress;

    # Initialize the executor with the agent and the query.
    #
    # + agent - Agent instance to be executed
    # + query - Natural language query to be executed by the agent
    # + history - Execution history of the agent (This is used to continue an execution paused without completing)
    # + context - Contextual information to be used by the agent during the execution
    public isolated function init(BaseAgent agent, string memoryId, *ExecutionProgress progress) {
        self.memoryId = memoryId;
        self.agent = agent;
        self.progress = progress;
    }

    # Checks whether agent has more steps to execute.
    #
    # + return - True if agent has more steps to execute, false otherwise
    public isolated function hasNext() returns boolean {
        return !self.isCompleted;
    }

    # Reason the next step of the agent.
    #
    # + return - generated LLM response during the reasoning or an error if the reasoning fails
    public isolated function reason() returns json|TaskCompletedError|LlmError {
        if self.isCompleted {
            return error TaskCompletedError("Task is already completed. No more reasoning is needed.");
        }
        return check self.agent.selectNextTool(self.progress, self.memoryId);
    }

    # Execute the next step of the agent.
    #
    # + llmResponse - LLM response containing the tool to be executed and the raw LLM output
    # + return - Observations from the tool can be any|error|null
    public isolated function act(json llmResponse) returns ExecutionResult|LlmChatResponse|ExecutionError {
        LlmToolResponse|LlmChatResponse|LlmInvalidGenerationError parseLlmResponse = self.agent.parseLlmResponse(llmResponse);
        if parseLlmResponse is LlmChatResponse {
            self.isCompleted = true;
            return parseLlmResponse;
        }

        anydata observation;
        ExecutionResult|ExecutionError executionResult;
        if parseLlmResponse is LlmToolResponse {
            ToolOutput|ToolExecutionError|LlmInvalidGenerationError output = self.agent.toolStore.execute(parseLlmResponse);
            if output is Error {
                if output is ToolNotFoundError {
                    observation = "Tool is not found. Please check the tool name and retry.";
                } else if output is ToolInvalidInputError {
                    observation = "Tool execution failed due to invalid inputs. Retry with correct inputs.";
                } else {
                    observation = "Tool execution failed. Retry with correct inputs.";
                }
                executionResult = {
                    llmResponse,
                    'error: output,
                    observation: observation.toString()
                };
            } else {
                anydata|error value = output.value;
                observation = value is error ? value.toString() : value;
                executionResult = {
                    tool: parseLlmResponse,
                    observation: value
                };
            }
        } else {
            observation = "Tool extraction failed due to invalid JSON_BLOB. Retry with correct JSON_BLOB.";
            executionResult = {
                llmResponse,
                'error: parseLlmResponse,
                observation: observation.toString()
            };
        }
        self.update({
            llmResponse,
            observation
        });
        return executionResult;
    }

    # Update the agent with an execution step.
    #
    # + step - Latest step to be added to the history
    public isolated function update(ExecutionStep step) {
        self.progress.history.push(step);
    }

    # Reason and execute the next step of the agent.
    #
    # + return - A record with ExecutionResult, chat response or an error 
    public isolated function next() returns record {|ExecutionResult|LlmChatResponse|ExecutionError|Error value;|}? {
        if self.isCompleted {
            return ();
        }
        json|TaskCompletedError|LlmError llmResponse = self.reason();
        if llmResponse is error {
            return {value: llmResponse};
        }
        return {value: self.act(llmResponse)};
    }
}

# Execute the agent for a given user's query.
#
# + agent - Agent to be executed
# + query - Natural langauge commands to the agent  
# + maxIter - No. of max iterations that agent will run to execute the task (default: 5)
# + context - Context values to be used by the agent to execute the task
# + verbose - If true, then print the reasoning steps (default: true)
# + memoryId - The ID associated with the memory
# + return - Returns the execution steps tracing the agent's reasoning and outputs from the tools
public isolated function run(BaseAgent agent, string query, int maxIter, string|map<json> context, boolean verbose,
        string memoryId = DEFAULT_MEMORY_ID) returns record {|(ExecutionResult|ExecutionError)[] steps; string answer?;|} {
    lock {
        (ExecutionResult|ExecutionError)[] steps = [];
        Memory|MemoryError memory = agent.memoryManager.getMemory(memoryId);
        if memory is Error {
            ExecutionError memoryExecutionError = {observation: "Unable to obtain memory", 'error: memory, llmResponse: ()};
            return {steps: [memoryExecutionError]};
        }
        string? content = ();
        Iterator iterator = new (agent, memoryId, query = query, context = context);
        int iter = 0;

        ChatUserMessage userMessage = {role: USER, content: query};
        updateMemory(memory, userMessage);

        ChatSystemMessage reactSystemMessage = agent is ReActAgent
            ? {role: SYSTEM, content: string `${agent.instructionPrompt} You can use these information if needed: ${context.toString()}`}
            : {role: SYSTEM, content: context.toString()};
        updateMemory(memory, reactSystemMessage);

        foreach ExecutionResult|LlmChatResponse|ExecutionError|Error step in iterator {
            if iter == maxIter {
                break;
            }
            if step is Error {
                error? cause = step.cause();
                log:printError("Error occured while executing the agent", step, cause = cause !is () ? cause.toString() : "");
                break;
            }
            if step is LlmChatResponse {
                content = step.content;
                if verbose {
                    io:println(string `${"\n\n"}Final Answer: ${step.content}${"\n\n"}`);
                }
                if agent is ReActAgent {
                    json finalAnswer = {action: "Final Answer", action_input: step.content};
                    ChatAssistantMessage assistantMessage = {role: ASSISTANT, content: string `${BACKTICKS}${finalAnswer.toJsonString()}${BACKTICKS}\"`};
                    updateMemory(memory, assistantMessage);
                    break;
                }
                ChatAssistantMessage assistantMessage = {role: "assistant", content: step.content};
                updateMemory(memory, assistantMessage);
                break;
            }
            iter += 1;
            if verbose {
                io:println(string `${"\n\n"}Agent Iteration ${iter.toString()}`);
                if step is ExecutionResult {
                    LlmToolResponse tool = step.tool;
                    io:println(string `Action:
    ${BACKTICKS}
    {
        ${ACTION_NAME_KEY}: ${tool.name},
        ${ACTION_ARGUEMENTS_KEY}: ${(tool.arguments ?: "None").toString()}
    }
    ${BACKTICKS}`);
                    anydata|error observation = step?.observation;
                    if observation is error {
                        io:println(string `${OBSERVATION_KEY} (Error): ${observation.toString()}`);
                    } else if observation !is () {
                        io:println(string `${OBSERVATION_KEY}: ${observation.toString()}`);
                    }
                } else {
                    error? cause = step.'error.cause();
                    io:println(string `LLM Generation Error: 
    ${BACKTICKS}
    {
        message: ${step.'error.message()},
        cause: ${(cause is error ? cause.message() : "Unspecified")},
        llmResponse: ${step.llmResponse.toString()}
    }
    ${BACKTICKS}`);
                }
            }
            updateExecutionResultInMemory(memory, step);
            steps.push(step);
        }
        return {steps, answer: content};
    }
}

isolated function getObservationString(anydata|error observation) returns string {
    if observation is () {
        return "Tool didn't return anything. Probably it is successful. Should we verify using another tool?";
    } else if observation is error {
        record {|string message; string cause?;|} errorInfo = {
            message: observation.message().trim()
        };
        error? cause = observation.cause();
        if cause is error {
            errorInfo.cause = cause.message().trim();
        }
        return "Error occured while trying to execute the tool: " + errorInfo.toString();
    } else {
        return observation.toString().trim();
    }
}

# Get the tools registered with the agent.
#
# + agent - Agent instance
# + return - Array of tools registered with the agent
public isolated function getTools(BaseAgent agent) returns AgentTool[] => agent.toolStore.tools.toArray();

public isolated function updateMemory(Memory memory, ChatMessage message) {
    error? updationStation = memory.update(message);
    if (updationStation is error) {
        log:printError("Error occured while updating the memory", updationStation);
    }
}

isolated function updateExecutionResultInMemory(Memory memory, ExecutionResult|LlmChatResponse|ExecutionError|Error step) {
    if step is ExecutionResult {
        LlmToolResponse tool = step.tool;
        anydata|error observation = step?.observation;

        ChatAssistantMessage assistantMessage = {
            role: ASSISTANT,
            function_call: {name: tool.name, id: tool.id, arguments: tool.arguments.toJsonString()}
        };
        updateMemory(memory, assistantMessage);

        ChatFunctionMessage functionMessage = {
            role: FUNCTION,
            name: tool.name,
            content: observation is error ?
                observation.toString() : observation is () ? "" : observation.toString(),
            id: tool.id
        };
        updateMemory(memory, functionMessage);
    }
}

// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerinax/ai.agent;
import ballerina/http;

listener http:Listener httpListener = http:getDefaultListener();
listener agent:Listener chatListener = new (httpListener);

service /chatService on chatListener {
    resource function post chat(@http:Payload agent:ChatReqMessage request) returns agent:ChatRespMessage|error {
        return {
            message: request.sessionId + ": " + request.message
        };
    }
}

// Copyright (c) 2023 WSO2 LLC (http://www.wso2.com).
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/regex;
import wso2/ai.agent;

configurable string openAIToken = ?;

type SearchParams record {|
    string query;
|};

type CalculatorParams record {|
    string expression;
|};

// create two mock tools 
isolated function searchToolMock(*SearchParams params) returns string {
    string query = params.query.trim().toLowerAscii();
    if regex:matches(query, ".*girlfriend.*") {
        return "Camila Morrone";

    } else if regex:matches(query, ".*age.*") {
        return "25 years";
    }
    else {
        return "Can't find. Stop!";
    }
}

isolated function calculatorToolMock(*CalculatorParams params) returns string {
    string expression = params.expression.trim();
    if expression == "25^0.43" {
        return "Answer: 3.991298452658078";
    } else {
        return "Can't compute. Some information is missing";
    }
}

const string DEFAULT_QUERY = "Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?";

public function main(string query = DEFAULT_QUERY) returns error? {
    agent:Tool searchTool = {
        name: "Search",
        description: " A search engine. Always use to look up for information.",
        parameters: {
            'properties: {
                "query": {
                    "type": "string",
                    "description": "The search query"
                }
            }
        },
        caller: searchToolMock
    };

    agent:Tool calculatorTool = {
        name: "Calculator",
        description: "Useful for when you need to answer questions about math.",
        parameters: {
            'properties: {
                "expression": {
                    "type": "string",
                    "description": "The expression to be evaluated"
                }
            }
        },
        caller: calculatorToolMock
    };

    agent:ChatGptModel model = check new ({auth: {token: openAIToken}});
    agent:FunctionCallAgent agent = check new (model, searchTool, calculatorTool);
    _ = agent:run(agent, query);
}

// Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
//
// WSO2 Inc. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

public type OrderItem record {|
    string category;
    string code;
    int qty;
|};

public type InventoryUpdated record {|
    *http:Ok;
|};

import ballerina/test;

@test:Config {}
function testResolveSchema() {

    ObjectInputSchema inputSchema = {
        'type: OBJECT,
        required: ["queryParams", "path"],
        properties: {
            path: {
                'const: "customsearch/v1"
            },
            queryParams: {
                'type: OBJECT,
                properties: {
                    q: {
                        'type: STRING,
                        default: "AIzaSyAYFLQpxzp5XlQGkAR8URuBJGr9YiiZyIU"
                    },
                    cx: {
                        'type: STRING,
                        default: "d60e6379e9234405a"
                    },
                    key: {
                        'type: STRING,
                        description: "the search query"

                    }
                }
            }
        }
    };

    map<json>|json[]? resolvedSchema = resolveSchema(inputSchema);

    if resolvedSchema !is map<json> {
        test:assertFail("resolveSchema output is not a map<json>");
    }

    test:assertEquals(resolvedSchema, {
                                          path: "customsearch/v1",
                                          queryParams: {
                                              q: "AIzaSyAYFLQpxzp5XlQGkAR8URuBJGr9YiiZyIU",
                                              cx: "d60e6379e9234405a"
                                          }
                                      });

    test:assertEquals(inputSchema, {
                                       'type: OBJECT,
                                       required: ["queryParams"],
                                       properties: {
                                           queryParams: {
                                               'type: OBJECT,
                                               properties: {
                                                   q: {
                                                       'type: STRING,
                                                       default: "AIzaSyAYFLQpxzp5XlQGkAR8URuBJGr9YiiZyIU"
                                                   },
                                                   cx: {
                                                       'type: STRING,
                                                       default: "d60e6379e9234405a"
                                                   },
                                                   key: {
                                                       'type: STRING,
                                                       description: "the search query"

                                                   }
                                               }
                                           }
                                       }
                                   });

}

@test:Config {}
function testExecuteSuccessfullOutput() returns error? {
    ToolConfig sendEmailTool = {
        name: "Send mail",
        description: "useful to send emails to a given recipient",
        parameters: {
            properties: {
                'input: {
                    properties: {
                        senderEmail: {'const: "ballerina@email.com"},
                        messageRequest: {
                            properties: {
                                to: {
                                    items: {'type: STRING}
                                },
                                subject: {'type: STRING},
                                body: {
                                    'type: STRING,
                                    format: "text/html"
                                }
                            }
                        }
                    }
                }
            }
        },
        caller: sendMail
    };
    LlmToolResponse sendMailInput = {
        name: "Send_mail",
        arguments: {
            input: {
                messageRequest: {
                    to: ["alica@wso2.com"],
                    subject: "Greetings Alica!",
                    body: "<h1>Hi Alica</h1><p>Welcome to ai.agent module Alica</p>"
                }
            }
        }
    };
    ToolStore toolStore = check new (sendEmailTool);
    ToolOutput output = check toolStore.execute(sendMailInput);
    if output.value is error {
        test:assertFail("tool execution output is an error");
    }
}

@test:Config {}
function testExecuteErrorOutput() returns error? {
    ToolConfig sendEmailTool = {
        name: "Send mail",
        description: "useful to send emails to a given recipient",
        parameters: {
            properties: {
                'input: {
                    properties: {
                        senderEmail: {'const: "test@email.com"},
                        messageRequest: {
                            properties: {
                                to: {
                                    items: {'type: STRING}
                                },
                                subject: {'type: STRING},
                                body: {
                                    'type: STRING,
                                    format: "text/html"
                                }
                            }
                        }
                    }
                }
            }
        },
        caller: sendMail
    };
    LlmToolResponse sendMailInput = {
        name: "Send_mail",
        arguments: {
            input: {
                messageRequest: {
                    to: ["alica@wso2.com"],
                    subject: "Greetings Alica!",
                    body: "<h1>Hi Alica</h1><p>Welcome to ai.agent module Alica</p>"
                }
            }
        }
    };
    ToolStore toolStore = check new (sendEmailTool);
    ToolOutput output = check toolStore.execute(sendMailInput);
    if output.value !is error {
        test:assertFail("tool execution output is not an error");
    }
}

@test:Config {}
function testExecutionError() returns error? {
    ToolConfig sendEmailTool = {
        name: "Send mail",
        description: "useful to send emails to a given recipient",
        parameters: {
            properties: {
                'input: {
                    properties: {
                        senderEmail: {'const: "ballerina@email.com"},
                        messageRequest: {
                            properties: {
                                to: {
                                    items: {'type: STRING}
                                },
                                subject: {'type: STRING},
                                body: {
                                    'type: STRING,
                                    format: "text/html"
                                }
                            }
                        }
                    }
                }
            }
        },
        caller: sendMail
    };
    LlmToolResponse sendMailInput = {
        name: "Send_mail",
        arguments: {
            input: {
                messageRequest: {
                    to: "alica@wso2.com", // errornous generation
                    subject: "Greetings Alica!",
                    body: "<h1>Hi Alica</h1><p>Welcome to ai.agent module Alica</p>"
                }
            }
        }
    };
    ToolStore toolStore = check new (sendEmailTool);
    ToolOutput output = check toolStore.execute(sendMailInput);
    if output.value !is error {
        test:assertFail("tool execution should return an error, yet it is succesfull");
    }
}

@test:Config {}
function testToolWithDefaultParameters() returns error? {
    ToolConfig testToolConfig = {
        name: "testTool",
        description: "testTool",
        parameters: {
            properties: {
                a: {'type: STRING},
                b: {'type: STRING},
                c: {'type: STRING}
            },
            required: ["a"]
        },
        caller: testTool
    };
    LlmToolResponse testToolInput = {
        name: "testTool",
        arguments: {
            a: "required",
            c: "override"
        }
    };
    ToolStore toolStore = check new (testToolConfig);
    ToolOutput output = check toolStore.execute(testToolInput);
    test:assertEquals(output.value, "required default-one override");
}

@test:Config {}
function testExecutionPanicError() returns error? {
    ToolConfig sendEmailTool = {
        name: "testToolPanic",
        description: "testToolPanic",
        parameters: {
            properties: {
                data: {'type: STRING}
            },
            required: ["data"]
        },
        caller: testToolPanic
    };
    LlmToolResponse sendMailInput = {
        name: "testToolPanic",
        arguments: {
            input: {
                messageRequest: {
                    data: "test"
                }
            }
        }
    };
    ToolStore toolStore = check new (sendEmailTool);
    ToolOutput|Error output = toolStore.execute(sendMailInput);
    if output !is Error {
        test:assertFail("tool execution should failed with erronous generation, yet it is succesfull");
    }
}

@test:Config
isolated function testInitializingToolStoreWithoutNoTools() returns error? {
    ToolStore toolStore = check new ();
    test:assertEquals(toolStore.tools.toArray().length(), 0);
}
